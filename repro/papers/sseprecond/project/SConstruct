from rsf.proj import *
import os

################################# DEFNS ##################################
CWPROOT         = os.getenv('CWPROOT')
sunull          = os.path.join(CWPROOT,'bin/sunull')
sushw           = os.path.join(CWPROOT,'bin/sushw')
suchw           = os.path.join(CWPROOT,'bin/suchw')
sugain          = os.path.join(CWPROOT,'bin/sugain')
suwind          = os.path.join(CWPROOT,'bin/suwind')
suwaveform      = os.path.join(CWPROOT,'bin/suwaveform')
supsimage       = os.path.join(CWPROOT,'bin/supsimage')
suspike         = os.path.join(CWPROOT,'bin/suspike')
sufilter        = os.path.join(CWPROOT,'bin/sufilter')
suconv          = os.path.join(CWPROOT,'bin/suconv')
sucddecon       = os.path.join(CWPROOT,'bin/sucddecon')
sufrac          = os.path.join(CWPROOT,'bin/sufrac')
sustack         = os.path.join(CWPROOT,'bin/sustack')
suop            = os.path.join(CWPROOT,'bin/suop')
sugain          = os.path.join(CWPROOT,'bin/sugain')
sumax           = os.path.join(CWPROOT,'bin/sumax')
suop2           = os.path.join(CWPROOT,'bin/suop2')
suflip          = os.path.join(CWPROOT,'bin/suflip')
sutxtaper       = os.path.join(CWPROOT,'bin/sutxtaper')
a2b             = os.path.join(CWPROOT,'bin/a2b')
suresamp        = os.path.join(CWPROOT,'bin/suresamp')
suamp           = os.path.join(CWPROOT,'bin/suamp')
sufft           = os.path.join(CWPROOT,'bin/sufft')
sushift         = os.path.join(CWPROOT,'bin/sushift')
MYAPPS          = os.getenv('MYAPPS')
asg             = os.path.join(MYAPPS,'trip/iwave/asg/main/sim.x')
asg0cgne        = os.path.join(MYAPPS,'trip/iwave/asg/main/sse.x')
asgfwi          = os.path.join(MYAPPS,'trip/iwave/asg/main/fwi.x')
deriv           = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYDeriv.x')
tscale          = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYTraceScale.x')
taper           = os.path.join(MYAPPS,'trip/iwave/trace/main/taper.x')
dot             = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYDot.x')
norm            = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYNorm.x')
offsc           = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYScalebyOffset.x')
cg8to10         = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYCGL8to10.x')
cg12to13         = os.path.join(MYAPPS,'trip/iwave/trace/main/SEGYCGL12to13.x')
#######################################################################

# dummy target
Flow('cout0.txt',None,'/usr/bin/touch $TARGET')

### parameters - three discretization levels

BULK = 4.0
BUOY = 1.0
DX   = [20,10,5]
DT   = [0.008,0.004,0.002]
NX   = [401,801,1601]
NTR  = [201,401,801]
FTR  = [75,150,300]
NZ   = [201,401,801]
NZTH = [31,31,31]
ZMTH = [2700,2850,2925]
NT   = [626,1251,2501]
NTS  = [251,501,1001]
F1   = [1,2,4]
F2   = [2.5,5,10]
F3   = [7.5,15,30]
F4   = [12.5,25,50]
CLIP = [0.08,0.24,0.8]
SCLIP= [20.0,80.0,320.0]
DF   = 0.248
RZ   = -1000
SZ   = -3000
DSZ  = -3500
RXMIN=  2000
SX   =  3500
TMIN = 1.0
TMAX = 3.0

# trapezoidal taper parameters - taper in gx only
TPIN = 'gx:2000,2500,5500,6000'
TP = 'gx:1000,1500,6000,6500'


################ discretization loop

#for i in range(0,3):
for i in [0]:

# scale for SSE maps: multiply by bulk/buoy because IWAVE does not scale RHS
# functions, dx because surface source implicitly integrates over surface

    PSCALE = DX[i]*BULK
    VSCALE = DX[i]*BUOY

# compute header files for receiver (rechdr) and source (srchdr) lines, at gelev
# = -1000 and -3000 resp.

    Flow('rechdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NT[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(RZ) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)
         
    Flow('srchdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NTS[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(SZ) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)

# near source lines, gelev=selev +/- delta z

    Flow('nsphdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NTS[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(SZ+5*DX[i]) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)

    Flow('nsmhdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NTS[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(SZ-5*DX[i]) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)

# near receiver lines

    Flow('nrphdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NT[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(RZ+5*DX[i]) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)

    Flow('nrmhdr' + str(i) + '.su', None,
         sunull + ' nt=' + str(NT[i]) +
         ' ntr=' + str(NTR[i]) +
         ' dt=' + str(DT[i]) + ' | ' + 
         sushw + ' key=gx a=' + str(RXMIN) +
         ' b=' + str(DX[i]) +
         ' j=' + str(NTR[i]) + ' | ' +
         sushw + ' key=gelev,selev,sx' +
         ' a=' + str(RZ-5*DX[i]) + ',' + str(SZ) + ',' + str(SX) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',
         stdin=0)

### src point source at z=3000, x=3500 = left end of line + 1500 m,
### scale by 500 for time delta (dt=0.002) and
### dx for dx integration

    Flow('ptsrc'+str(i)+'.su', None, suspike +
         ' nt=' + str(NTS[i]) + ' ntr=' + str(NTR[i]) + ' offset=0 ix1=' + str(FTR[i]) + ' nspk=1 it1=' + str(NTS[i]/2) + ' dt=' + str(DT[i]) + ' | ' +
         sufilter + ' f=' +
         str(F1[i]) + ',' + str(F2[i]) + ',' +
         str(F3[i]) + ',' + str(F4[i]) + ' | ' +
         sugain + ' scale=' + str(DX[i]/DT[i]) + ' | ' + 
         sushw + ' key=delrt,gelev,selev,sx' +
         ' a=0,' + str(SZ) + ',' + str(SZ) + ',' + str(SX) + ' | ' + 
         sushw + ' key=gx a=2000 b=' + str(DX[i]) + ' j=' + str(NTR[i]) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',         
         stdin=0)

### deeper src point source at z=3500, x=3500 = left end of line + 1500 m,
### scale by 500 for time delta (dt=0.002) and
### dx for dx integration

    Flow('dptsrc'+str(i)+'.su', None, suspike +
         ' nt=' + str(NTS[i]) + ' ntr=' + str(NTR[i]) + ' offset=0 ix1=' + str(FTR[i]) + ' nspk=1 it1=' + str(NTS[i]/2) + ' dt=' + str(DT[i]) + ' | ' +
         sufilter + ' f=' +
         str(F1[i]) + ',' + str(F2[i]) + ',' +
         str(F3[i]) + ',' + str(F4[i]) + ' | ' +
         sugain + ' scale=' + str(DX[i]/DT[i]) + ' | ' + 
         sushw + ' key=delrt,gelev,selev,sx' +
         ' a=-500,' + str(DSZ) + ',' + str(DSZ) + ',' + str(SX) + ' | ' + 
         sushw + ' key=gx a=2000 b=' + str(DX[i]) + ' j=' + str(NTR[i]) + ' | ' +
         suchw + ' key1=offset key2=gx key3=sx c=-1',         
         stdin=0)

### create bulk modulus and buoyancy files

    NXL=NX[i]
    NZL=NZ[i]
    DXL=DX[i]
    DTL=DT[i]

# homog bulk
    Flow('bmh'+str(i), None, 
         'makevel n1=' + str(NZL) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) + 
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Bulk_modulus unit=GPa' +
         ' v000=' + str(BULK) + ' | ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0)

# homog buoy
    Flow('byh'+str(i), None, 
         'makevel n1=' + str(NZL) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) + 
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Buoyancy unit=cc/g' +
         ' v000=' + str(BUOY) + ' | ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0) 

# lens bulk
    Flow('bml'+str(i), None, 
         'makevel n1=' + str(NZL) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) + 
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Bulk_modulus unit=GPa' +
         ' v000=' + str(BULK) + 
         ' x1lens=2000 x2lens=4000 dlens=700 tlens=1500 vlens=-2.4| ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0)

# weak lens
    Flow('bmw'+str(i), None, 
         'makevel n1=' + str(NZL) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) + 
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Bulk_modulus unit=GPa' +
         ' v000=' + str(BULK) + 
         ' x1lens=2000 x2lens=4000 dlens=700 tlens=1500 vlens=-0.4| ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0)

# thin models

    Flow('bmhth'+str(i), None, 
         'makevel n1=' + str(NZTH[i]) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) +
         ' o1=' + str(ZMTH[i]) +
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Bulk_modulus unit=GPa' +
         ' v000=' + str(BULK) + ' | ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0)

    Flow('byhth'+str(i), None, 
         'makevel n1=' + str(NZTH[i]) + ' n2=' + str(NXL) +
         ' d1=' + str(DXL) + ' d2=' + str(DXL) +
         ' o1=' + str(ZMTH[i]) +
         ' label1=Depth label2=Distance' + 
         ' unit1=m unit2=m' + 
         ' label=Buoyancy unit=cc/g' +
         ' v000=' + str(BUOY) + ' | ' +
         ' sfput dim=2 gdim=2 id1=0 id2=1',
         stdin=0)

# simulation commands - hard-wire common options

# usage:
#    Flow([outp, outvz],
#         [inbmod, inbuoy, inhdr, inp, invz],
#         cmd, stdin=0, stdout=-1)

    fwdcmd ='''
    /bin/cp ${SOURCES[2]} ${TARGETS[0]} &&
    /bin/cp ${SOURCES[2]} ${TARGETS[1]} &&
    ''' + \
    taper + ' input=${SOURCES[3]} output=${SOURCES[3]}.taper.su ' + \
    'taperpars=' + TP + ' && ' + \
    sugain + '< ${SOURCES[3]}.taper.su > ${SOURCES[3]}' + \
    '.deltaz.su scale=' + str(PSCALE) + ' && ' + \
    taper + ' input=${SOURCES[4]} output=${SOURCES[4]}.taper.su ' + \
    'taperpars=' + TP + ' && ' + \
    sugain + '< ${SOURCES[4]}.taper.su > ${SOURCES[4]}' + \
    '.deltaz.su scale=' + str(VSCALE) + ' && ' + \
    asg + ' ' + \
    'source_p=${SOURCES[3]}' + '.deltaz.su ' + \
    'source_v0=${SOURCES[4]}' + '.deltaz.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
    deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP

    adjcmd = \
    '/bin/cp ${SOURCES[2]} ${TARGETS[0]}' + '.undeltaz.su && ' + \
    '/bin/cp ${SOURCES[2]} ${TARGETS[1]}' + '.undeltaz.su && ' + \
    sugain + '< ${SOURCES[3]} > ${SOURCES[3]}' + '.scaled.su' + \
    ' scale=1.0 && ' + \
    sugain + '< ${SOURCES[4]} > ${SOURCES[4]}' + '.scaled.su ' + \
    ' scale=' +  str(-BUOY/BULK) + ' && ' + \
    asg + ' ' + \
    'source_p=${TARGETS[0]}' + '.undeltaz.su ' + \
    'source_v0=${TARGETS[1]}' + '.undeltaz.su ' + \
    'data_p=${SOURCES[3]}' + '.scaled.su ' + \
    'data_v0=${SOURCES[4]}' + '.scaled.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP + ' && ' + \
    sugain + '< ${TARGETS[0]}' + '.undeltaz.su > ${TARGETS[0]}.taper.su' + \
    ' scale=' + str(PSCALE) + ' && ' + \
    taper + ' input=${TARGETS[0]}.taper.su output=${TARGETS[0]} ' + \
    'taperpars=' + TP + ' && ' + \
    sugain + '< ${TARGETS[1]}' + '.undeltaz.su > ${TARGETS[1]}.taper.su' + \
    ' scale=' + str(-PSCALE) + ' && ' + \
    taper + ' input=${TARGETS[1]}.taper.su output=${TARGETS[1]} ' + \
    'taperpars=' + TP

### symmetric lambda command, from equation \ref{winvcomp}
### list of sources:
### 0: bulkmod
### 1: buoyancy
### 2: null receiver gather to generate workspace
### 3: pressure gather on source manifold, input as source_v0 

### list of targets:
### 0: output pressure source gather
### 1: receiver p gather (intermediate)
### 2: receiver v0 gather (intermediate)

### note that fwd output p is used as vz source and fwd
### fwd output vz is used as p source - this is the operator
### Pi_0 Pi_1^T + Pi_1 Pi_0^T in equation wcomp.

### scales are from analysis of relation between iwave operators
### and theoretical counterparts

    lamcmd = \
    sugain + '< ${SOURCES[3]} > ${TARGETS[0]}.undeltaz.su ' + \
    ' scale=0.0 && ' + \
    '/bin/cp ${SOURCES[2]} ${TARGETS[1]} && ' + \
    '/bin/cp ${SOURCES[2]} ${TARGETS[2]} && ' + \
    sugain + '< ${SOURCES[3]} > ${SOURCES[3]}' + \
    '.deltaz.su scale=' + str(VSCALE) + ' && ' + \
    asg + ' ' + \
    'source_v0=${SOURCES[3]}' + '.deltaz.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    data_p=${TARGETS[1]} data_v0=${TARGETS[2]}
    deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP + ' && ' + \
    sugain + '< ${TARGETS[1]} > ${TARGETS[1]}' + '.scaled.su' + \
    ' scale=' + str(-BUOY/BULK) + ' && ' + \
    sugain + '< ${TARGETS[2]} > ${TARGETS[2]}' + '.scaled.su ' + \
    ' scale=' + str(1.0) + ' && ' + \
    asg + ' ' + \
    'source_v0=${TARGETS[0]}' + '.undeltaz.su ' + \
    'data_p=${TARGETS[2]}' + '.scaled.su ' + \
    'data_v0=${TARGETS[1]}' + '.scaled.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP + ' && ' + \
    sugain + '< ${TARGETS[0]}' + '.undeltaz.su > ${TARGETS[0]}' + \
    ' scale=' + str(4*PSCALE)

### symmetric lambda inverse command, from equation \ref{wcomp}
### list of sources:
### 0: bulkmod
### 1: buoyancy
### 2: null receiver gather to generate workspace
### 3: pressure source gather, input as source_p 

### list of targets:
### 0: output pressure gather
### 1: receiver p gather (intermediate)
### 2: receiver v0 gather (intermediate)

### note that fwd output p is used as vz source and fwd
### fwd output vz is used as p source - this is the operator
### Pi_0 Pi_1^T + Pi_1 Pi_0^T in equation wcomp.

### scales are from analysis of relation between iwave operators
### and theoretical counterparts

    laminvcmd = \
    sugain + '< ${SOURCES[3]} > ${TARGETS[0]}.undeltaz.su ' + \
    ' scale=0.0 && ' + \
    '/bin/cp ${SOURCES[2]} ${TARGETS[1]} && ' + \
    '/bin/cp ${SOURCES[2]} ${TARGETS[2]} && ' + \
    sugain + '< ${SOURCES[3]} > ${SOURCES[3]}' + \
    '.deltaz.su scale=' + str(PSCALE) + ' && ' + \
    asg + ' ' + \
    'source_p=${SOURCES[3]}' + '.deltaz.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    data_p=${TARGETS[1]} data_v0=${TARGETS[2]}
    deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP + ' && ' + \
    sugain + '< ${TARGETS[1]} > ${TARGETS[1]}' + '.scaled.su' + \
    ' scale=' + str(-BUOY/BULK) + ' && ' + \
    sugain + '< ${TARGETS[2]} > ${TARGETS[2]}' + '.scaled.su ' + \
    ' scale=' + str(1.0) + ' && ' + \
    asg + ' ' + \
    'source_p=${TARGETS[0]}' + '.undeltaz.su ' + \
    'data_p=${TARGETS[2]}' + '.scaled.su ' + \
    'data_v0=${TARGETS[1]}' + '.scaled.su ' + \
    '''
    bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
    deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
    dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
    taperpars=
    ''' + TP + ' && ' + \
    sugain + '< ${TARGETS[0]}' + '.undeltaz.su > ${TARGETS[0]}' + \
    ' scale=' + str(-4*VSCALE)

### test case - compare output to dfwdphh0.su, dfwdvzhh0.su

    Flow(['dfwdphh' + str(i) + 'test.su',
          'dfwdvzhh' + str(i) + 'test.su'],
         ['bmh' + str(i) + '.rsf', 'byh' + str(i) + '.rsf',
          'rechdr' + str(i) + '.su',
	  'dhshh' + str(i) + '.su', 'srchdr' + str(i) + '.su'],
          fwdcmd, stdin=0, stdout=-1)

############### ADJOINT TESTS ##################

# adjoint test - p source to p receivers 

    Flow('adjtestp' + str(i) + '.txt',
        ['bmh' + str(i),
         'byh' + str(i),
         'rechdr' + str(i) + '.su',
         'ptsrc' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_p=${SOURCES[3]} data_p=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 adjtest=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         taperpars=
         ''' + TP, stdin=0)

# adjoint test - vz source to vz receivers

    Flow('adjtestvz' + str(i) + '.txt',
        ['bmh' + str(i),
         'byh' + str(i),
         'rechdr' + str(i) + '.su',
         'ptsrc' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_v0=${SOURCES[3]} data_v0=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 adjtest=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         taperpars=
         ''' + TP, stdin=0)

# adjoint test - v0 sources to p receivers

    Flow('adjtestvzp' + str(i) + '.txt',
        ['bmh' + str(i),
         'byh' + str(i),
         'rechdr' + str(i) + '.su',
         'srchdr' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_v0=${SOURCES[3]} data_p=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         adjtest=1 taperpars=
         ''' + TP, stdin=0)

# adjoint test - p sources to v0 receivers

    Flow('adjtestpvz' + str(i) + '.txt',
        ['bmh' + str(i),
         'byh' + str(i),
         'rechdr' + str(i) + '.su',
         'srchdr' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_p=${SOURCES[3]} data_v0=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 sampord=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         adjtest=1 taperpars=
         ''' + TP, stdin=0)

# adjoint test - p sources to near p receivers 

    Flow('nradjtestp' + str(i) + '.txt',
        ['bmhth' + str(i),
         'byhth' + str(i),
         'nsphdr' + str(i) + '.su',
         'ptsrc' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_p=${SOURCES[3]} data_p=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 adjtest=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         taperpars=
         ''' + TP, stdin=0)

# adjoint test - vz sources to near vz receivers

    Flow('nradjtestvz' + str(i) + '.txt',
        ['bmhth' + str(i),
         'byhth' + str(i),
         'nsphdr' + str(i) + '.su',
         'ptsrc' + str(i) + '.su'],
         asg + 
         '''
         bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
         source_v0=${SOURCES[3]} data_v0=${SOURCES[2]} 
         deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 adjtest=1
         dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
         taperpars=
         ''' + TP, stdin=0)

################ GENERATE DATA BY BACK-PROPAGATION ################

### medium loop:
### hh = homog data inverted in homog medium
### lh = lens data inverted in homog medium
### ll = lens data inverted in lens medium

    for med in ['hh', 'lh', 'll']:

        exp = med + str(i)

### simulate deep point source data p, vz traces, record at
### source datum

        Flow(['dsrcp' + exp + '.su', 'dsrcvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'dptsrc' + str(i) + '.su',
              'srchdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### go all the way

        Flow(['drecp' + exp + '.su', 'drecvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'dptsrc' + str(i) + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### scale vz for coefficient of p source

        Flow('dhs'+exp+'.su','dsrcvz'+exp+'.su',
             sugain + ' scale=' + str(-2.0))

### scale coefficient to source

        Flow('dhsdeltaz'+exp+'.su','dhs'+exp+'.su',
             sugain + ' scale=' + str(PSCALE))
             
### scale p for vz source coeffcient

        Flow('dfs'+exp+'.su','dsrcp'+exp+'.su',
             sugain + ' scale=' + str(-2.0))

### *VSCALE))

        Flow('dfsdeltaz'+exp+'.su','dfs'+exp+'.su',
             sugain + ' scale=' + str(VSCALE))
             
### simulate filtered source data p, vz traces using
### p src 
### fwdp = S srcvzg,

        Flow(['dfwdp' + exp + '.su', 'dfwdvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'dhsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1) 

### simulate filtered source data p, vz traces using p traces as
### vz src. From snull identity, 
### daltp = Pi_0 {\cal S} Pi_1^T dfs
### daltvz = Pi_1 {\cal S} Pi_1^T dfs

        Flow(['daltp' + exp + '.su', 'daltvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'dfsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1) 

################## APPROXIMATE INVERSION ###################

### apply transpose of computed V operator. V operator = computed V operator x
### V scale. So transpose of Voperator = V scale x transpose of computed V
### operator. Need 4 x transpose of V operator
### 

        Flow(['dinvp' + exp + '.su',
              'dinvvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
	      'rechdr' + str(i) + '.su',
              'dfwdp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[4]} data_p=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

        Flow('dinvhs'+exp+'.su','dinvvz'+exp+'.su',
             sugain + ' scale=' + str(4*VSCALE))

# check that adjcmd gives same result with less pain

        Flow(['dinvpnew' + exp + '.su',
              'dinvvznew' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
	      'rechdr' + str(i) + '.su',
              'dfwdp' + exp + '.su'],
	      adjcmd, stdin=0, stdout=-1)

        Flow('dinvhsnew'+exp+'.su','dinvvznew'+exp+'.su',
             sugain + ' scale=4.0')

#### resimulate USING SAME MODEL AS INVERSION

        Flow('dinvhsdeltaz'+exp+'.su','dinvhs'+exp+'.su',
             sugain + ' scale=' + str(PSCALE))

        Flow(['drerecp' + exp + '.su', 'drerecvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'dinvhsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

        Flow('ddiffrecp'+exp+'.su',
            ['drecp'+exp+'.su','drerecp'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff',
            stdin=0)
 
        Flow(['dreinvp' + exp + '.su',
              'dreinvvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'drerecp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

        Flow('dreinvhs'+exp+'.su','dreinvvz'+exp+'.su',
             sugain + ' scale=' + str(4.0*VSCALE))

        Flow('dreinvhsdeltaz'+exp+'.su','dreinvhs'+exp+'.su',
             sugain + ' scale=' + str(PSCALE))

        Flow(['drererecp' + exp + '.su', 'drererecvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'dreinvhsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

        Flow(['drereinvp' + exp + '.su',
              'drereinvvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'drererecp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)
        Flow('drereinvhs'+exp+'.su','drereinvvz'+exp+'.su',
             sugain + ' scale=' + str(4.0*VSCALE))

################## Normal

### apply adjoint of S to dfwdp

        Flow(['dnorp' + exp + '.su',
              'dnorvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'dfwdp' + exp + '.su',
	      'rechdr' + str(i) + '.su'],
	      adjcmd, stdin=0, stdout=-1)

### inverse normal = 16 V^TV

        Flow(['dvnorp' + exp + '.su',
	      'dvnorvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'rechdr' + str(i) + '.su',
	      'srchdr' + str(i) + '.su',
	      'dnorp' + exp + '.su'],
	      fwdcmd, stdin=0, stdout=-1)

        Flow(['dinvnorp' + exp + '.su',
	      'dinvnorvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
	      'rechdr' + str(i) + '.su',
	      'dvnorvz' + exp + '.su'],
	      adjcmd, stdin=0, stdout=-1)


        Flow('dinvnorhs' + exp + '.su',
	     'dinvnorvz' + exp + '.su',
	     sugain + ' scale=16.0')


################## Lambda

### forward propagate scaled srcp gather as vz source, read out p
### gather at receivers - note that this needs  Pi_0 {\cal S} Pi_1^T srcp,
### = daltp as defined above

### Pi_0 {cal S}^+ Pi_1^T dsrcp

        Flow(['dsrcprecp' + exp + '.su',
	      'dsrcprecvz' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'rechdr' + str(i) + '.su',
	       'srchdr' + str(i) + '.su',
	       'dsrcp' + exp + '.su'],
	       fwdcmd, stdin=0, stdout=-1)
	       
### V transpose applied to output

        Flow(['dresrcp' + exp + '.su',
              'dresrcvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'rechdr' + str(i) + '.su',
	      'dsrcprecp' + exp + '.su'],
             adjcmd, stdin=0, stdout=-1)

### Lambda output hs - should approximate dhs and dinvhs

        Flow('preddinvhs'+exp+'.su','dresrcvz'+exp+'.su',
             sugain + ' scale=' + str(-8.0))

        Flow('ddiffinvhs'+exp+'.su',
            ['dinvhs'+exp+'.su','preddinvhs'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')

### resimulate drecp and compare

        Flow(['dpredhsrecp' + exp + '.su',
	      'dpredhsrecvz' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'rechdr' + str(i) + '.su',
	       'preddinvhs' + exp + '.su',
	       'srchdr' + str(i) + '.su'],
	       fwdcmd, stdin=0, stdout=-1)

        Flow('ddiffpredhsrecp'+exp+'.su',
            ['drecp'+exp+'.su','dpredhsrecp'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')

### transpose

################## use near traces

### Pi_0 {cal S}^+ Pi_1^T dsrcp

        Flow(['dsrcpnsp' + exp + '.su',
	      'dsrcpnsvz' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'nsphdr' + str(i) + '.su',
	       'srchdr' + str(i) + '.su',
	       'dsrcp' + exp + '.su'],
	       fwdcmd, stdin=0, stdout=-1)
	       
### V transpose applied to output

        Flow(['dnssrcp' + exp + '.su',
              'dnssrcvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'nsphdr' + str(i) + '.su',
	      'dsrcpnsp' + exp + '.su'],
             adjcmd, stdin=0, stdout=-1)

### Lambda output hs - should approximate dhs and dinvhs

        Flow('preddnshs'+exp+'.su','dnssrcvz'+exp+'.su',
             sugain + ' scale=' + str(-8.0))

        Flow('ddiffnshs'+exp+'.su',
            ['dhs'+exp+'.su','preddnshs'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')

### resimulate drecp and compare

        Flow(['dprednshsrecp' + exp + '.su',
	      'dprednshsrecvz' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'rechdr' + str(i) + '.su',
	       'preddnshs' + exp + '.su',
	       'srchdr' + str(i) + '.su'],
	       fwdcmd, stdin=0, stdout=-1)

        Flow('ddiffprednshsrecp'+exp+'.su',
            ['drecp'+exp+'.su','dprednshsrecp'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')

### Lambda^T

### V dsrcp - already computed

        Flow(['dsrcpnspbis' + exp + '.su',
	      'dsrcpnsvzbis' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'nsphdr' + str(i) + '.su',
	       'srchdr' + str(i) + '.su',
	       'dsrcp' + exp + '.su'],
	       fwdcmd, stdin=0, stdout=-1)
	       
### Pi_1 ({cal S}^+)^T Pi_0^T applied to output

        Flow(['dnssrcptr' + exp + '.su',
              'dnssrcvztr' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
	      'dsrcpnsvzbis' + exp + '.su',
              'nsphdr' + str(i) + '.su'],
             adjcmd, stdin=0, stdout=-1)

### Lambda^T output hs - should approximate dhs and dinvhs, and
### be very close to Lambda output

        Flow('preddnshstr'+exp+'.su','dnssrcvztr'+exp+'.su',
             sugain + ' scale=' + str(-8.0))

        Flow('ddiffnslamtr' + exp + '.su',
            ['preddnshs'+exp+'.su','preddnshstr'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')
	
### symmetrized Lambda output

        Flow(['symmdnshs' + exp + '.su',
	      'symmdnsintp' + exp + '.su',
	      'symmdnsintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
	      'dsrcp' + exp + '.su'],
             lamcmd, stdin=0, stdout=-1)

### resimulate

        Flow(['dfwdpsymmdnshs' + exp + '.su',
	      'dfwdvzsymmdnshs' + exp + '.su'],
	      ['bm' + exp[1] + str(i),
	       'byh' + str(i),
	       'rechdr' + str(i) + '.su',
	       'symmdnshs' + exp + '.su',
	       'srchdr' + str(i) + '.su'],
	       fwdcmd, stdin=0, stdout=-1)

### compare with direct simulation

        Flow('ddiffsymmdnshs' + exp + '.su',
            ['dfwdp'+exp+'.su','dfwdpsymmdnshs'+exp+'.su'],
            suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')

### comparison with average

        Flow('avgdnshs' + exp + '.su',
	       ['preddnshs' + exp + '.su',
	        'preddnshstr' + exp + '.su'],
             suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=sum | ' + \
	     sugain + ' scale=0.5', stdin=0)
	     
####################### lambda comp with near traces #########

### simulate filtered source data p, vz traces using p traces as
### vz src. From snull identity, 
### daltp = Pi_0 {\cal S} Pi_1^T dfs
### daltvz = Pi_1 {\cal S} Pi_1^T dfs

### simulate filtered source data p, vz traces using p traces as
### vz src. From snull identity, 
### daltp = Pi_0 {\cal S} Pi_1^T dfs
### daltvz = Pi_1 {\cal S} Pi_1^T dfs

        Flow(['dnsaltp' + exp + '.su', 'dnsaltvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'dfsdeltaz' + exp + '.su',
              'nsphdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1) 

### V transpose

        Flow(['dnsresrcp' + exp + '.su',
              'dnsresrcvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'dnsaltp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### lambda dfs

        Flow('dnslamfs'+exp+'.su','dnsresrcvz'+exp+'.su',
             sugain + ' scale=' + str(-8.0*VSCALE))
             
### equivalent hs - should approximate dhs and dinvhs

        Flow('preddnsinvhs'+exp+'.su','dnslamfs'+exp+'.su',
             sugain + ' scale=' + str(-0.5))

### does it work - resim of dfwdp

### scale coefficient to source

        Flow('preddnsinvhsdeltaz'+exp+'.su','preddnsinvhs'+exp+'.su',
             sugain + ' scale=' + str(PSCALE))
             
### simulate filtered source data p, vz traces using
### p src 
### fwdp = S srcvzg,

        Flow(['dnsfwdp' + exp + '.su', 'dnsfwdvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'preddnsinvhsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

################ unitarity

### compute LSL, (SL = dfwdp, LSL = -2 dfwdvz) with V = altvz

        Flow('dsvcomp' + exp + '.su',
             ['daltvz' + exp + '.su',
              'dfwdvz' + exp + '.su'],
              suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff',
              stdin=0)
              
### apply S^T to Lambda_r P_r p = 2 P_r v_z
# note change of sign because of orientation: (-jump) is +2 P_r v_z

        Flow('drerecvzdeltaz' + exp + '.su',
             'drerecvz' + exp + '.su',
             sugain + ' scale=' + str(2.0))

        Flow(['dreunp' + exp + '.su',
              'dreunvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'drerecvzdeltaz' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_p=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

# Lambda_s S^T Lambda_r = -2

        Flow('dreunhs'+exp+'.su','dreunvz'+exp+'.su',
             sugain + ' scale=' + str(-2.0*PSCALE))

### now do same thing with symmetrized lambda

### apply symm Lambda_r to drecp

        Flow(['lamrdrecp' + exp + '.su',
	      'lamrdintp' + exp + '.su',
	      'lamrdintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nrphdr' + str(i) + '.su',
	      'drecp' + exp + '.su'],
             lamcmd, stdin=0, stdout=-1)
        
### apply S^T

        Flow(['stlamrdrecp' + exp + '.su',
              'stlamrdrecpvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
	      'lamrdrecp' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             adjcmd, stdin=0, stdout=-1)

### apply symm Lambda_s

        Flow(['lamsstlamrdrecp' + exp + '.su',
	      'lamsstlamrdintp' + exp + '.su',
	      'lamsstlamrdintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
	      'stlamrdrecp' + exp + '.su'],
             lamcmd, stdin=0, stdout=-1)

        Flow('difflamsstlamrdrecp' + exp + '.su',
	     ['lamsstlamrdrecp' + exp + '.su',
	      'dinvhs' + exp + '.su'],
	     suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff')
	     
##############################################################
########################### point source at z_s=3 km

### simulate point source data p, vz traces

        Flow(['recp' + exp + '.su', 'recvz' + exp + '.su'],
             ['bm' + exp[0] + str(i),
              'byh' + str(i),
              'ptsrc' + str(i) + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1) 

### apply transpose of \cal S. What is computed: R \cal S R. However this is not \cal S^T: that has wrong sign in off-diagonals. SO srcp gets a minus sign.

        Flow(['srcptmp' + exp + '.su',
              'srcvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'ptsrc' + str(i) + '.su',
              'recp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### apply minus sign to p trace

        Flow('srcp' + exp + '.su', 'srcptmp' + exp + '.su',
             sugain + ' scale=' + str(-1.0))
             
### scale for V operator - output = source coefficient gather

        Flow('invhs'+exp+'.su','srcvz'+exp+'.su',
             sugain + ' scale=' + str(4*VSCALE))

### scale for extended source on z=z_s

        Flow('invhsdeltaz'+exp+'.su','invhs'+exp+'.su',
             sugain + ' scale=' + str(PSCALE))
             
### resimulate USING SAME MODEL AS INVERSION

        Flow(['fwdp' + exp + '.su', 'fwdvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'invhsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_p=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### difference plot

        Flow('diffrecp'+exp+'.su',
             ['recp'+exp+'.su','fwdp'+exp+'.su'],
             suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=diff',
             stdin=0)

###################### Lambda computation

### Pi_0 {\cal S} Pi_1^T invfs

        Flow('invfs'+exp+'.su','srcp'+exp+'.su',
             sugain + ' scale=' + str(4*VSCALE))

        Flow('invfsdeltaz' + exp + '.su',
             'invfs' + exp + '.su',
             sugain + ' scale=' + str(VSCALE));
             
        Flow(['altp' + exp + '.su', 'altvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'invfsdeltaz' + exp + '.su',
              'rechdr' + str(i) + '.su'],
             '/bin/cp ${SOURCES[3]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[3]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${SOURCES[2]} data_p=${TARGETS[0]} data_v0=${TARGETS[1]}
             deriv=0 adjoint=0 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### V^T

        Flow(['resrcp' + exp + '.su',
              'resrcvz' + exp + '.su'],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'ptsrc' + str(i) + '.su',
              'altp' + exp + '.su'],
             '/bin/cp ${SOURCES[2]} ${TARGETS[0]}; ' +
             '/bin/cp ${SOURCES[2]} ${TARGETS[1]}; ' +
             asg + 
             '''
             bulkmod=${SOURCES[0]} buoyancy=${SOURCES[1]} 
             source_v0=${TARGETS[1]} source_p=${TARGETS[0]}
             data_v0=${SOURCES[3]}
             deriv=0 adjoint=1 order=2 cfl=0.5 cmin=1.0 cmax=3.0 
             dmin=0.8 dmax=3.0 nl1=250 nr1=250 nl2=250 nr2=250 pmlampl=1.0
             dump_lda=1 dump_ldc=1 dump_term=1 sampord=1 taperpars=
             ''' + TP, stdin=0, stdout=-1)

### lambda invfs

        Flow('laminvfs'+exp+'.su','resrcvz'+exp+'.su',
             sugain + ' scale=' + str(-8.0*VSCALE))


### equivalent hs - should approximate invhs

        Flow('predinvhs'+exp+'.su','laminvfs'+exp+'.su',
             sugain + ' scale=' + str(-0.5))

########################## LAM INVERSE ###################

        Flow(['laminvsymmdnshs' + exp + '.su',
	      'laminvsymmdnsintp' + exp + '.su',
	      'laminvsymmdnsintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
	      'symmdnshs' + exp + '.su'],
             laminvcmd, stdin=0, stdout=-1)

## commute test
# scale by offset factor

        Flow('adinvhs' + exp + '.su',
	     'dinvhs' + exp + '.su',
	     offsc + ' input=${SOURCE} output=${TARGET} shift=0.0 ' + \
	     'alpha=1.0 p=0.5', stdin=0, stdout=-1)
	     
# apply laminv to dinvhs

        Flow(['laminvadinvhs' + exp + '.su',
	      'laminvadinvhsintp' + exp + '.su',
	      'laminvadinvhsintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
	      'adinvhs' + exp + '.su'],
             laminvcmd, stdin=0, stdout=-1)

# scale by offset factor

        Flow('alaminvadinvhs' + exp + '.su',
	     'laminvadinvhs' + exp + '.su',
	     offsc + ' input=${SOURCE} output=${TARGET} shift=0.0 ' + \
	     'alpha=1.0 p=0.5', stdin=0, stdout=-1)
	     
# apply lam to result

        Flow(['lamalaminvadinvhs' + exp + '.su',
	      'lamalaminvadinvhsintp' + exp + '.su',
	      'lamalaminvadinvhsintvz' + exp + '.su'],
	     ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
	      'alaminvadinvhs' + exp + '.su'],
             lamcmd, stdin=0, stdout=-1)

# scale dinvhs directly

        Flow('atadinvhs' + exp + '.su',
	     'dinvhs' + exp + '.su',
	     offsc + ' input=${SOURCE} output=${TARGET} shift=0.0 ' + \
	     'alpha=1.0 p=1.0', stdin=0, stdout=-1)
	     
########################## CG & PCG ############################

### define number of its, alpha

        alphalist = [0.0, 1.e-3]

        itmax = 21

        ch = 0

        alpha = alphalist[ch]
	
        expsu = exp + '.su'

######################### PCG ####################################

### data residual - 0th residual = input data

        Flow('pcgd0'+expsu, 'recp'+expsu,
	     '/bin/cp ${SOURCE} ${TARGET}',
	     stdin=0, stdout=-1)
	
### initialize

##### h0

        Flow('pcgh0'+expsu, 'srchdr' + str(i) + '.su',
	     '/bin/cp ${SOURCE} ${TARGET}',
	     stdin=0,stdout=-1)

##### r0 = S^T Lam_r d0

        Flow(['pcglamrecp'+expsu, 'pcgdnrp0'+expsu, 'pcgdnrvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nrphdr' + str(i) + '.su',
              'pcgd0'+expsu],
             lamcmd, stdin=0, stdout=-1)		

        Flow(['pcgr0'+expsu,'pcgr0vz'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'pcglamrecp'+expsu,
              'rechdr' + str(i) + '.su'],
             adjcmd, stdin=0, stdout=-1)

#### start report files

        Flow('pcg' + str(ch) + 'nres0' + exp + '.txt', 'pcgr0'+expsu,
             norm + ' in=${SOURCE} >> ${TARGET}',
	     stdin=0, stdout=-1)

        Flow('pcg' + str(ch) + 'res0' + exp + '.txt', 'pcgd0'+expsu,
             norm + ' in=${SOURCE} >> ${TARGET}',
	     stdin=0, stdout=-1)

##### p0 = M^-1 r0

# tp0 = (1+alpha^2 x^2)^-1/2 r0
        Flow('pcgtp0'+expsu,
	     'pcgr0'+expsu,
	     offsc + ' input=${SOURCE} output=${TARGET} ' + \
	     'shift=1.0 alpha=' + str(alpha) + ' p=-0.5',
	     stdin=0, stdout=-1)

# lamtp0 = Lam_s tp0

        Flow(['pcglamtp0'+expsu, 'pcgnsp0'+expsu, 'pcgnsvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
              'pcgtp0'+expsu],
             lamcmd, stdin=0, stdout=-1)	

# p0 = (1+alpha^2 x^2)^-1/2 lamtp0

        Flow('pcgp0'+expsu,
	     'pcglamtp0'+expsu,
	     offsc + ' input=${SOURCE} output=${TARGET} ' + \
	     'shift=1.0 alpha=' + str(alpha) + ' p=-0.5',
	     stdin=0, stdout=-1)
	     
##### g0

        Flow('pcgg0'+expsu,'pcgp0'+expsu,
             '/bin/cp ${SOURCE} ${TARGET}',
             stdin=0, stdout=-1)

##### q0 = N p0

# S^T Lam_r S p0

        Flow(['pcgs0'+expsu,'pcgsvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'rechdr' + str(i) + '.su',
              'pcgp0'+expsu,
              'srchdr' + str(i) + '.su'],
              fwdcmd, stdin=0, stdout=-1)

        Flow(['pcglams0'+expsu, 'pcgnrp0'+expsu, 'pcgnrvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nrphdr' + str(i) + '.su',
              'pcgs0'+expsu],
             lamcmd, stdin=0, stdout=-1)	
	    
        Flow(['pcgq1t0'+expsu,'pcgq0vz'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'pcglams0'+expsu,
              'rechdr' + str(i) + '.su'],
              adjcmd, stdin=0, stdout=-1)

# alpha^2 A^T Lam_s^-1 A p0

        Flow('pcgqap0'+expsu,'pcgp0'+expsu,
	     offsc + ' input=${SOURCE} output=${TARGET} ' + \
	     'shift=0.0 alpha=' + str(alpha) + ' p=0.5',
	     stdin=0, stdout=-1)

        Flow(['pcglaminvap0'+expsu, 'pcgnsapp0'+expsu, 'pcgnsapvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'nsphdr' + str(i) + '.su',
              'pcgqap0'+expsu],
             laminvcmd, stdin=0, stdout=-1)	

        Flow('pcgq2t0'+expsu,'pcglaminvap0'+expsu,
	     offsc + ' input=${SOURCE} output=${TARGET} ' + \
	     'shift=0.0 alpha=' + str(alpha) + ' p=0.5',
	     stdin=0, stdout=-1)
	     
# N p0

        Flow('pcgq0'+expsu,
	    ['pcgq1t0'+expsu, 'pcgq2t0'+expsu],
	    suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=sum',
	    stdin=0)
	    
# Iteration loop

        for it in range(itmax):


### define filename tails
            ctail = str(it) + expsu
            ptail = str(it+1) + expsu

### lines 8-10 
	    
            Flow(['pcgh'+ptail, 'pcgr'+ptail, 'pcgd'+ptail],
	         ['pcgh'+ctail, 'pcgr'+ctail, 'pcgd'+ctail,
		  'pcgg'+ctail, 'pcgp'+ctail, 'pcgq'+ctail],
		 cg8to10 + \
		 ' hc=pcgh' + ctail +\
		 ' hp=pcgh' + ptail +\
		 ' rc=pcgr' + ctail +\
		 ' rp=pcgr' + ptail +\
		 ' dc=pcgd' + ctail +\
		 ' dp=pcgd' + ptail +\
                 ' g=pcgg' + ctail +\
                 ' p=pcgp' + ctail +\
		 ' s=pcgs' + ctail +\
                 ' q=pcgq' + ctail,
		 stdin=0, stdout=-1)

### line 11

##### g_it+1 = M^-1 r_it+1

# tr_it+1 = (1+alpha^2 x^2)^-1/2 r_it+1

            Flow('pcgtr'+ptail,
	         'pcgr'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=1.0 alpha=' + str(alpha) + ' p=-0.5',
	         stdin=0, stdout=-1)

# lamtr_it+1 = lam_s tr_it+1

            Flow(['pcglamtr'+ptail, 'pcgnsp'+ptail, 'pcgnsvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'nsphdr' + str(i) + '.su',
                  'pcgtr'+ptail],
                 lamcmd, stdin=0, stdout=-1)	

# g_it+1 = (1+alpha^2 x^2)^-1/2 lamtr_it+1

            Flow('pcgg'+ptail,
	         'pcglamtr'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=1.0 alpha=' + str(alpha) + ' p=-0.5',
	         stdin=0, stdout=-1)

### lines 12-13
            Flow('pcgp'+ptail,
                ['pcgr'+ctail,'pcgr'+ptail,'pcgg'+ctail,
		'pcgg'+ptail,'pcgp'+ctail],
                cg12to13 + \
                 ' pp=pcgp'+ptail +\
	         ' pc=pcgp'+ctail +\
	         ' gp=pcgg'+ptail +\
	         ' gc=pcgg'+ctail +\
                 ' rp=pcgr'+ptail +\
	         ' rc=pcgr'+ctail,
	        stdin=0,stdout=-1)

### line 14 : S p_it+1

            Flow(['pcgs'+ptail,'pcgsvz'+ptail],
	         ['bm' + exp[1] + str(i),
	          'byh' + str(i),
	          'rechdr' + str(i) + '.su',
	          'pcgp'+ptail,
	          'srchdr' + str(i) + '.su'],
	          fwdcmd, stdin=0, stdout=-1)

### Lam_r S p_it+1

            Flow(['pcglams'+ptail, 'pcgnlamsp'+ptail, 'pcgnlamsvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'nrphdr' + str(i) + '.su',
                  'pcgs'+ptail],
                 lamcmd, stdin=0, stdout=-1)	

# S^T Lam_r S p_it+1

            Flow(['pcgq1t'+ptail,'pcgqvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'srchdr' + str(i) + '.su',
                  'pcglams'+ptail,
                  'rechdr' + str(i) + '.su'],
                 adjcmd, stdin=0, stdout=-1)

# alpha^2 A^T lamsinv A p_it+1

            Flow('pcgap'+ptail,'pcgp'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=0.0 alpha=' + str(alpha) + ' p=0.5',
	         stdin=0, stdout=-1)

            Flow(['pcglaminvap'+ptail, 'pcgnsapp'+ptail, 'pcgnsapvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'nsphdr' + str(i) + '.su',
                  'pcgap'+ptail],
                 laminvcmd, stdin=0, stdout=-1)	

            Flow('pcgq2t'+ptail,'pcglaminvap'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=0.0 alpha=' + str(alpha) + ' p=0.5',
	         stdin=0, stdout=-1)
		 
# N p_it+1

            Flow('pcgq'+ptail,
	        ['pcgq1t'+ptail, 'pcgq2t'+ptail],
	        suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=sum',
	        stdin=0)

#### reports
	    
            Flow('pcg' + str(ch) + 'nres' + str(it+1) + exp+'.txt',
		['pcgr'+ptail, 'pcg'+str(ch) + 'nres' + str(it) + exp+'.txt'],
		 '/bin/cp ${SOURCES[1]} ${TARGET} && ' + \
                 norm + ' in=${SOURCES[0]} >> ${TARGET}',
                 stdin=0, stdout=-1)

            Flow('pcg' + str(ch) + 'res' + str(it+1) + exp+'.txt',
		['pcgd'+ptail, 'pcg' + str(ch) + 'res' + str(it) + exp+'.txt'],
		 '/bin/cp ${SOURCES[1]} ${TARGET} && ' + \
                 norm + ' in=${SOURCES[0]} >> ${TARGET}',
                 stdin=0, stdout=-1)

### compute final residual directly

            Flow(['pcg' + str(ch) + 'sim'+ptail,'pcgsimvz'+ptail],
	         ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'rechdr' + str(i) + '.su',
                  'pcgh'+ptail,
                  'srchdr' + str(i) + '.su'],
                  fwdcmd, stdin=0, stdout=-1)

            Flow('pcg'+str(ch)+'resid'+ptail,
	         ['pcgd0'+exp+'.su','pcg'+str(ch)+'sim'+ptail],
		 suop2 + ' ${SOURCES[0]} ${SOURCES[1]}',
		 stdin=0)

            Flow('pcg'+str(ch)+'h'+ptail,
	         'pcgh'+ptail,
                 '/bin/cp ${SOURCE} ${TARGET}',
		 stdin=0, stdout=-1)
		 
######################### CG ####################################

### data residual - 0th residual = input data

        Flow('cgd0'+expsu, 'recp'+expsu,
	     '/bin/cp ${SOURCE} ${TARGET}',
	     stdin=0, stdout=-1)
	
### initialize

##### h0

        Flow('cgh0'+expsu, 'srchdr' + str(i) + '.su',
	     '/bin/cp ${SOURCE} ${TARGET}',
	     stdin=0,stdout=-1)

##### r0 = S^T d0

        Flow(['cgr0'+expsu,'cgr0vz'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'cgd0'+expsu,
              'rechdr' + str(i) + '.su'],
             adjcmd, stdin=0, stdout=-1)

#### start report files

        Flow('cg' + str(ch) + 'nres0' + exp + '.txt', 'cgr0'+expsu,
             norm + ' in=${SOURCE} >> ${TARGET}',
	     stdin=0, stdout=-1)

        Flow('cg' + str(ch) + 'res0' + exp + '.txt', 'cgd0'+expsu,
             norm + ' in=${SOURCE} >> ${TARGET}',
	     stdin=0, stdout=-1)

##### p0 = r0

        Flow('cgp0'+expsu, 'cgr0'+expsu,
	     '/bin/cp ${SOURCE} ${TARGET}',
	     stdin=0,stdout=1)
	     
##### g0 = p0

        Flow('cgg0'+expsu,'cgp0'+expsu,
             '/bin/cp ${SOURCE} ${TARGET}',
             stdin=0, stdout=-1)

##### q0 = N p0

# S^T S p0

        Flow(['cgs0'+expsu,'cgsvz0'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'rechdr' + str(i) + '.su',
              'cgp0'+expsu,
              'srchdr' + str(i) + '.su'],
              fwdcmd, stdin=0, stdout=-1)

        Flow(['cgq1t0'+expsu,'cgq0vz'+expsu],
             ['bm' + exp[1] + str(i),
              'byh' + str(i),
              'srchdr' + str(i) + '.su',
              'cgs0'+expsu,
              'rechdr' + str(i) + '.su'],
              adjcmd, stdin=0, stdout=-1)

# alpha^2 A^T A p0

        Flow('cgq2t0'+expsu,'cgp0'+expsu,
	     offsc + ' input=${SOURCE} output=${TARGET} ' + \
	     'shift=0.0 alpha=' + str(alpha) + ' p=1.0',
	     stdin=0, stdout=-1)
	     
# N p0

        Flow('cgq0'+expsu,
	    ['cgq1t0'+expsu, 'cgq2t0'+expsu],
	    suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=sum',
	    stdin=0)
	    
# Iteration loop

        for it in range(itmax):

### define filename tails
            ctail = str(it) + expsu
            ptail = str(it+1) + expsu

### lines 8-10
	    
            Flow(['cgh'+ptail, 'cgr'+ptail, 'cgd'+ptail],
	         ['cgh'+ctail, 'cgr'+ctail, 'cgd'+ctail,
		  'cgg'+ctail, 'cgp'+ctail, 'cgq'+ctail],
		 cg8to10 + \
		 ' hc=cgh' + ctail +\
		 ' hp=cgh' + ptail +\
		 ' rc=cgr' + ctail +\
		 ' rp=cgr' + ptail +\
		 ' dc=cgd' + ctail +\
		 ' dp=cgd' + ptail +\
                 ' g=cgg' + ctail +\
                 ' p=cgp' + ctail +\
		 ' s=cgs' + ctail +\
                 ' q=cgq' + ctail,
		 stdin=0, stdout=-1)

### line 11

##### g_it+1 = M^-1 r_it+1

# tr_it+1 = (1+alpha^2 x^2)^-1/2 r_it+1

            Flow('cgtr'+ptail,
	         'cgr'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=1.0 alpha=' + str(alpha) + ' p=-0.5',
	         stdin=0, stdout=-1)

# lamtr_it+1 = lam_s tr_it+1

            Flow(['cglamtr'+ptail, 'cgnsp'+ptail, 'cgnsvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'nsphdr' + str(i) + '.su',
                  'cgtr'+ptail],
                 lamcmd, stdin=0, stdout=-1)	

# g_it+1 = r_it+1

            Flow('cgg'+ptail,'cgr'+ptail,
                 '/bin/cp ${SOURCE} ${TARGET}',
		 stdin=0, stdout=-1)

### lines 12-13
            Flow('cgp'+ptail,
                ['cgr'+ctail,'cgr'+ptail,'cgg'+ctail,
		'cgg'+ptail,'cgp'+ctail],
                cg12to13 + \
                 ' pp=cgp'+ptail +\
	         ' pc=cgp'+ctail +\
	         ' gp=cgg'+ptail +\
	         ' gc=cgg'+ctail +\
                 ' rp=cgr'+ptail +\
	         ' rc=cgr'+ctail,
	        stdin=0,stdout=-1)

### line 14 : S p_it+1

            Flow(['cgs'+ptail,'cgsvz'+ptail],
	         ['bm' + exp[1] + str(i),
	          'byh' + str(i),
	          'rechdr' + str(i) + '.su',
	          'cgp'+ptail,
	          'srchdr' + str(i) + '.su'],
	          fwdcmd, stdin=0, stdout=-1)

# S^T S p_it+1

            Flow(['cgq1t'+ptail,'cgqvz'+ptail],
                 ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'srchdr' + str(i) + '.su',
                  'cgs'+ptail,
                  'rechdr' + str(i) + '.su'],
                 adjcmd, stdin=0, stdout=-1)

# alpha^2 A^T A p_it+1

            Flow('cgq2t'+ptail,'cgp'+ptail,
	         offsc + ' input=${SOURCE} output=${TARGET} ' + \
	         'shift=0.0 alpha=' + str(alpha) + ' p=1.0',
	         stdin=0, stdout=-1)
		 
# N p_it+1

            Flow('cgq'+ptail,
	        ['cgq1t'+ptail, 'cgq2t'+ptail],
	        suop2 + ' ${SOURCES[0]} ${SOURCES[1]} op=sum',
	        stdin=0)

#### reports
	    
            Flow('cg' + str(ch) + 'nres' + str(it+1) + exp+'.txt',
		['cgr'+ptail, 'cg'+str(ch) + 'nres' + str(it) + exp+'.txt'],
		 '/bin/cp ${SOURCES[1]} ${TARGET} && ' + \
                 norm + ' in=${SOURCES[0]} >> ${TARGET}',
                 stdin=0, stdout=-1)

            Flow('cg' + str(ch) + 'res' + str(it+1) + exp+'.txt',
		['cgd'+ptail, 'cg' + str(ch) + 'res' + str(it) + exp+'.txt'],
		 '/bin/cp ${SOURCES[1]} ${TARGET} && ' + \
                 norm + ' in=${SOURCES[0]} >> ${TARGET}',
                 stdin=0, stdout=-1)

### compute final residual directly

            Flow(['cg'+str(ch)+'sim'+ptail,'jnk'+ptail],
	         ['bm' + exp[1] + str(i),
                  'byh' + str(i),
                  'rechdr' + str(i) + '.su',
                  'cgh'+ptail,
                  'srchdr' + str(i) + '.su'],
                  fwdcmd, stdin=0, stdout=-1)

            Flow('cg'+str(ch)+'resid'+ptail,
	         ['cgd0'+exp+'.su','cg'+str(ch)+'sim'+ptail],
		 suop2 + ' ${SOURCES[0]} ${SOURCES[1]}',
		 stdin=0)

            Flow('cg'+str(ch)+'h'+ptail,
	         'cgh'+ptail,
		 '/bin/cp ${SOURCE} ${TARGET}',
		 stdin=0, stdout=-1)

######################### compare cg, pcg #####################

        Flow(['compres'+str(ch)+exp+'.rsf', 'compres'+str(ch)+exp+'.dat'],
	     ['cg'+str(ch)+'res20'+exp+'.txt',
	      'pcg'+str(ch)+'res20'+exp+'.txt'],
	     'echo n1=21 o1=0 d1=1 >  ${TARGETS[0]} && ' + \
	     'echo n2=2  o2=0 d2=1 >> ${TARGETS[0]} && ' + \
	     'echo data_format=ascii_float >> ${TARGETS[0]} && ' + \
             'echo in=${TARGETS[1]} >> ${TARGETS[0]} && ' + \
	     '/bin/cat ${SOURCE} >  ${TARGETS[1]} && ' + \
	     '/bin/cat p${SOURCE} >> ${TARGETS[1]}',
	     stdin=0, stdout=-1)

        Flow(['compnres'+str(ch)+exp+'.rsf', 'compnres'+str(ch)+exp+'.dat'],
	     ['cg'+str(ch)+'nres20'+exp+'.txt',
	      'pcg'+str(ch)+'nres20'+exp+'.txt'],
	     'echo n1=21 o1=0 d1=1 >  ${TARGETS[0]} && ' + \
	     'echo n2=2  o2=0 d2=1 >> ${TARGETS[0]} && ' + \
	     'echo data_format=ascii_float >> ${TARGETS[0]} && ' + \
             'echo in=${TARGETS[1]} >> ${TARGETS[0]} && ' + \
	     '/bin/cat ${SOURCE} >  ${TARGETS[1]} && ' + \
	     '/bin/cat p${SOURCE} >> ${TARGETS[1]}',
	     stdin=0, stdout=-1)

########################## graphics ###########################

        tmin = [1.2, 1.2, 1.2, 1.2,
                0.0, 0.0, 0.0,
                1.2,
                0.0, 0.0,
                0.0, 0.0,
                0.0,
                1.2, 1.2,
                0.0, 0.0, 1.2, 1.2,
                0.0, 0.0, 1.2, 1.2,
		0.0, 0.0, 0.0, 0.0,
		1.2,
		0.0, 0.0,
                1.2, 1.2, 1.2,
                1.2, 1.2, 1.2]
        tmax = [3.0, 3.0, 3.0, 3.0,
                2.0, 2.0, 2.0,
                3.0,
                2.0, 2.0,
                2.0, 2.0,
                2.0,
                3.0, 3.0,
                2.0, 2.0, 3.0, 3.0,
                2.0, 2.0, 3.0, 3.0,
		2.0, 2.0, 2.0, 2.0,
		3.0,
                2.0, 2.0,		
                3.0, 3.0, 3.0,
                3.0, 3.0, 3.0]
        clip = [0.08, 0.08, 0.08, 0.08,
                5.0, 5.0, 5.0,
                0.08,
                0.2, 0.2,
                0.2, 0.2,
                0.2,
                0.08, 0.08,
                0.2, 0.2, 0.08, 0.08,
                0.2, 0.2, 0.08, 0.08,
		0.2, 0.2, 0.2, 0.2,
		0.08,
		0.2, 0.2,
                0.08, 0.08, 0.08,
                0.08, 0.08, 0.08]
        id   = ['recp', 'recvz', 'fwdp', 'altp',
                'invfs', 'invhs', 'predinvhs',
                'diffrecp',
                'dsrcp', 'dsrcvz',
                'dhs', 'dfs',
                'dinvhs',
                'drerecp', 'ddiffrecp',
                'preddinvhs', 'ddiffinvhs', 'dpredhsrecp', 'ddiffpredhsrecp',
                'preddnshs', 'ddiffnshs', 'dprednshsrecp', 'ddiffprednshsrecp',
		'preddnshstr', 'ddiffnslamtr', 'symmdnshs', 'avgdnshs',
		'ddiffsymmdnshs',
		'lamsstlamrdrecp', 'difflamsstlamrdrecp',
                'drecp', 'dfwdp', 'daltp',
                'dfwdvz', 'daltvz', 'dsvcomp']
                
        for j in range(len(id)):
        
            gid = id[j] + exp
            
### convert gathers to rsf

            Flow(gid, gid + '.su',
                 'suread read=data endian=0')
             
### pull out traces

            for k in [21, 51, 81]:

                tid = gid + 'tr' + str(k)
        
                Flow(tid + '.su',
                     gid + '.su',
                     suwind + ' key=tracl min=' + str(k) + ' max=' + str(k))

### convert traces to rsf

                Flow(tid, tid + '.su',
                     'suread read=data endian=0')

### plot gathers

            Result(gid,
                  'window min1=' + str(tmin[j]) +
                  ' max1=' + str(tmax[j]) + ' | ' 
                  'grey color=j clip=' + str(clip[j]) +
                  ' scalebar=y minval=-' + str(clip[j]) +
                  ' maxval=' + str(clip[j]) + ' wanttitle=n')

### plot traces

        for k in [21, 51, 81]:

            Result('drecp' + exp + 'tr' + str(k),
                  ['drecp' + exp + 'tr' + str(k),
                   'dfwdp' + exp + 'tr' + str(k)],
                  '''
                  cat axis=2 ${SOURCES[1:2]} | window min1=1.2 max1=3.0 |
                  graph plotcol=5,6 plotfat=4,4 wanttitle=n label2=Pressure unit2=GPa
                  ''')

            Result('daltp' + exp + 'tr' + str(k),
                  ['drecp' + exp + 'tr' + str(k),
                   'daltp' + exp + 'tr' + str(k)],
                  '''
                  cat axis=2 ${SOURCES[1:2]} | window min1=1.2 max1=3.0 |
                  graph plotcol=5,6 plotfat=4,4 wanttitle=n label2=Pressure unit2=GPa
                  ''')
                  
            Result('invhs' + exp + 'tr' + str(k),
                  ['invhs' + exp + 'tr' + str(k),
                   'predinvhs' + exp + 'tr' + str(k)],
                  '''
                  cat axis=2 ${SOURCES[1:2]} |
                  graph plotcol=5,6 plotfat=4,4 wanttitle=n label2=Pressure unit2=GPa
                  ''')

            Result('recp' + exp + 'tr' + str(k),
                  ['recp' + exp + 'tr' + str(k),
                   'fwdp' + exp + 'tr' + str(k)],
                  '''
                  cat axis=2 ${SOURCES[1:2]} | window min1=1.2 max1=3.0 |
                  graph plotcol=5,6 plotfat=4,4 wanttitle=n label2=Pressure unit2=GPa
                  ''')

        Result('compres'+str(ch)+exp,
	       'graph color=5,6 plotfat=4 min2=0.0 wanttitle=n')

        Result('compnres'+str(ch)+exp,
	       'graph color=5,6 plotfat=4 min2=0.0 wanttitle=n')
	       
Result('bml0', 'grey color=j scalebar=y wanttitle=n label1=z label2=x unit1=m unit2=m barunit=GPa xinch=10 yinch=5')
    
End()
