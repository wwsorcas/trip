<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>RVL: The Rice Vector Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RVL
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Rice Vector Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Authors: Anthony D. Padula, Shannon D. Scott, and William W. Symes<br />
 Other contributors: Hala Dajani, Marco Enriquez, Dong Sun</p>
<p><a class="el" href="namespaceRVL.html">RVL</a> defines computational types realizing the principal concepts of calculus in vector spaces, in the form of C++ classes. Brief descriptions of the main classes follow. For a more complete description of each, and for a list of auxiliary classes and functions, see the <a href="http://portal.acm.org/citation.cfm?doid=1499096.1499097">TOMS paper</a> and the class documentation. </p>
<ul>
<li>
<p class="startli"><b>Vector space:</b> mathematically, a set and a number field, together with a linear combination operation, satisfying certain axioms. The computational realization of an (infinite) set is a <em>factory</em>, that is, a object (<a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a>) which will return a dynamically allocated data structure necessary to describe a vector, upon request. The linear combination operation is an attribute of the space. The vector spaces emulated by <a class="el" href="namespaceRVL.html">RVL</a> are also equipped with an inner product, that is, are Hilbert spaces. The only coordinate-invariant choice of vector is the zero vector. Spaces must be comparable, so that one can tell whether a vector is a member or not. Thus <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a> has five major attributes: a protected method building vector data, and four public methods: inner, linComb, zero (applying to member vectors) and operator== (comparison of spaces). The number field associated with the space is a template parameter of <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a>. <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a> is an abstract (pure virtual) base class. </p>
<p>In principle, defining a usable (concrete) subclass involves implementing all five basic methods. <a class="el" href="namespaceRVL.html">RVL</a> provides an partially implemented <a class="el" href="classRVL_1_1StdSpace.html" title="Standard modular RVL space class. ">RVL::StdSpace</a> subclass which implements the three vector methods and encapsulates the others, for spaces whose vector data structure is <em>local</em>, that is, consists of (any number of) elemental parts which expose scalar arrays (pointers) - see <a href="../../../local/doc/html/index.html">LocalRVL</a>. The principal work involved in implementing a new space using <a class="el" href="classRVL_1_1StdSpace.html" title="Standard modular RVL space class. ">RVL::StdSpace</a> is the definition of the vector instance data structure (<a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a>, see below) appropriate to the space, and designing code to test equality of spaces. Since the space comparison (operator==) will be used in all of the vector function classes listed below, implementations should be as efficient as possible.  </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Vectors:</b> vectors are members of spaces, hence meaningless in themselves. Thus <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a> is a concrete (fully implemented) class whose instances own (i) a reference to the <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a> of which the vector is a member, and (ii) instance data in the form of an <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a>. <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a> construction uses the <a class="el" href="classRVL_1_1Space.html#ad8aca3a3b3914d30ec975c1266fcef27" title="returns a dynamically allocated DataContainer. ">RVL::Space::buildDataContainer</a> method to acquire its <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a> member, and delegates linear algebra methods to the <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a> of which it is a "member". Note that <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a> is a concrete, non-virtual class, and the user will not need (nor, indeed, be able) to implement subclasses - use <em>as is!</em>  </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Linear Operators:</b> a linear operator is a function. A function has a domain and a range, and a rule for assigning members of the former to members of the latter. A linear operator on a Hilbert space has an adjoint operator. [Strictly speaking, densely defined linear operators have well-defined adjoints, but for technical reasons all linear operators constructable in <a class="el" href="namespaceRVL.html">RVL</a> are densely defined.] For these reasons, the <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">RVL::LinearOp</a> type has four key public attributes: (i) <a class="el" href="classRVL_1_1Operator.html#a3b7cbfefe58026a52c3661cc809fed48" title="access to domain, range ">RVL::LinearOp::getDomain()</a> returns an <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a>, as does (ii) <a class="el" href="classRVL_1_1Operator.html#a8dcecfca9984c45821fddcb94a8d9ebd">RVL::LinearOp::getRange()</a>; (iii) <a class="el" href="classRVL_1_1LinearOp.html#a396464766d28352f88d09bb48079709d" title="This function assigns to  the value . ">RVL::LinearOp::applyOp</a> takes input and output Vector arguments, as does (iv) <a class="el" href="classRVL_1_1LinearOp.html#a5a4410ad0d4c5fcd90ab97b80395d422" title="This function assigns to  the value . ">RVL::LinearOp::applyAdjOp</a>. <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">RVL::LinearOp</a> is an abstract base class. The public domain and range methods are pure virtual must be implemented. The apply...Op methods are implemented, in terms of protected <a class="el" href="classRVL_1_1Operator.html#a3f648f6900a4cb776d1f24797699d67d" title="1-jet at a point, accessible only through OperatorEvaluation and subclasses. ">RVL::LinearOp::apply</a> and <a class="el" href="classRVL_1_1LinearOp.html#ad7a10df22e165fddff0c20ffa6be14e2" title="Evaluation of adjoint linear operator on constant input vector x, output written on mutable vector y...">RVL::LinearOp::applyAdj</a>. This device, replicated in the other function classes, allows installation of the obvious sanity test in the public (implemented) interface: calling <a class="el" href="classRVL_1_1LinearOp.html#a396464766d28352f88d09bb48079709d" title="This function assigns to  the value . ">RVL::LinearOp::applyOp</a> with (const) input <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a> and (mutable) output <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a> invokes a test using the <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a> comparison method to assure that the input is in the domain, and the output in the range. The actual evaluation takes place in the user-defined protected functions. The important consequences of this design are that (1) the user may write the evaluation code assuming that all attributes related to domain and range spaces are correct (for example, dimensions, sample rates, array lengths, etc.), because (2) the evaluation code is only accessible via the public interface, which enforces these constraints.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Nonlinear Functions and Operators:</b> <a class="el" href="namespaceRVL.html">RVL</a> uses "Functional" to describe scalar-valued functions, and "Operator" to describe vector-valued functions. Being functions, both <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> and <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">RVL::Operator</a> have a getDomain() method, and <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">RVL::Operator</a> has a getRange() method - the range of an <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> being the scalar field passed via template parameter. Those are the only public methods. Computation of value, derivative, adjoint derivative, etc. must be supplied to create a usable subclass, by implementation of protected methods declared as pure virtual in the base classes. </p>
<p>Thus applications do not access the computational methods directly. Instead, access to these computations proceeds through an <em>evaluation</em> class. <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">RVL::FunctionalEvaluation</a> and <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">RVL::OperatorEvaluation</a> combine a function and a vector, and return the value of the function at that vector, the value of its derivative (a linear operator), and (optionally) the value of the second derivative (as a bilinear operator), each these encapsulated as an appropriate <a class="el" href="namespaceRVL.html">RVL</a> object. While <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> and <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">RVL::Operator</a> are abstract base classes, and the various protecte apply... methods must be implemented to build instantiable subclasses. <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">RVL::FunctionalEvaluation</a> and <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">RVL::OperatorEvaluation</a> are fully implemented. Their sanity-check input and output objects, and delegate the actual evaluation to the protected methods defined in <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> and <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">RVL::Operator</a> subclasses, after the pattern of the <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">RVL::LinearOp</a> apply... methods. Thus these user-defined protected methods can be written with assurance that all domain and range requirements are satisfied. </p>
<p>The Evaluation class concept was introduced in the Hilbert Class Library and further developed in <a class="el" href="namespaceRVL.html">RVL</a>. Besides automated sanity checks, the Evaluation device ensures that the various objects attached to a function at a point of its domain (value, derivative,...) remain coherent, and avoids a great deal of redundant effort otherwise necessary for correct programming. The evaluation technique has various consequences for the construction of functions, described in the <a href="http://portal.acm.org/citation.cfm?doid=1499096.1499097">TOMS paper</a>.  </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Data structures and low-level functions:</b> RVL::DataContainers typically do not expose their data - otherwise, out-of-core data, or data distributed over the net, would not be representable. Instead, interaction with data occurs through evaluation of <em>function objects</em> (functions with persistent state). <a class="el" href="namespaceRVL.html">RVL</a> supplies two hierarchies of function objects, based at <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">RVL::FunctionObject</a> and <a class="el" href="classRVL_1_1FunctionObjectConstEval.html" title="Membership. ">RVL::FunctionObjectConstEval</a> (according to whether evaluation may alter the <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a> doing the evaluating, or not). <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a> is also an abstract base, for which evaluation of the two types of function object must be defined in subclasses. These three hierarchies form an instance of the acyclic Visitor design pattern, with <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a> as the Element type and the two function object classes as the Visitor types. Much of the programming effort in building an <a class="el" href="namespaceRVL.html">RVL</a> application goes into designing and implementing <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">RVL::DataContainer</a> subclasses encapsulating various concrete data structures, and <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">RVL::FunctionObject</a> and <a class="el" href="classRVL_1_1FunctionObjectConstEval.html" title="Membership. ">RVL::FunctionObjectConstEval</a> types to manipulate these data structures.  </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Auxiliary Constructs:</b> </p><ul>
<li>
<p class="startli"><b>Products:</b> Most scientific data of any complexity is <em>compound</em>, that is, consists of a number of component data structures. Linear algebraically, such data define points in Cartesian product vector spaces. <a class="el" href="namespaceRVL.html">RVL</a> supplies an abstract notion of Cartesian product (<a class="el" href="classRVL_1_1Product.html" title="Simple Cartesian product mixin. ">RVL::Product</a>, RVL::ROPRoduct), and partly (<a class="el" href="classRVL_1_1ProductSpace.html" title="Abstract base class expressing behaviour of Cartesian products of vector spaces. ">RVL::ProductSpace</a>) and fully (<a class="el" href="classRVL_1_1StdProductSpace.html" title="Standard construction of product spaces, via an (STL) vector of dynamically allocated Spaces...">RVL::StdProductSpace</a>) implemented realizations of Cartesian product vector space using the product interface. Based on these, various specializations of the function classes (<a class="el" href="classRVL_1_1BlockOperator.html" title="Operator defined with product domain and range. ">RVL::BlockOperator</a>, <a class="el" href="classRVL_1_1FunctionalProductDomain.html" title="A specialization of Functional which also has partial derivatives. ">RVL::FunctionalProductDomain</a>) are also supplied. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Tests:</b> A great deal of application development time can be saved by elemental component tests. For computational realizations of linear and nonlinear functions, two of the most important are (1) adjoint test - check that implemented adjoint pairs of linear operators (<a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">RVL::LinearOp</a>) are really adjoint to each other, at least to a modest multiple of machine precision, and (2) derivative test - check that computed derivative are consistent with divided differences, over some range of steps. <a class="el" href="namespaceRVL.html">RVL</a> supplies implemented standalone functions (<a class="el" href="namespaceRVL.html#a4f4c54c14907a1a59176a38230bdd215" title="Test of adjoint relationship between applyOp and applyAdjOp methods of a LinearOp. ">RVL::AdjointTest</a>, <a class="el" href="namespaceRVL.html#a54fd266fc449300086fc5a142b16bcba" title="tests accuracy of directional derivative computation by comparison with centered finite difference ap...">RVL::DerivTest</a>, <a class="el" href="namespaceRVL.html#ab5912f017113d3e671381e333e38d743" title="This implementation of the gradient test should be sufficient for all Functionals. ">RVL::GradientTest</a>) for both purposes, which can be inserted into drivers with one or two lines of code, and produce formatted diagnostic output.  </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Traits:</b> class template <a class="el" href="structRVL_1_1ScalarFieldTraits.html" title="A traits class to extend the capabilities of numeric_limits without duplicating such capabilities...">RVL::ScalarFieldTraits</a> that abstracts the standard properties of scalar fields; use enables more portable code. For example, the float version of 1.0 is <a class="el" href="structRVL_1_1ScalarFieldTraits.html" title="A traits class to extend the capabilities of numeric_limits without duplicating such capabilities...">RVL::ScalarFieldTraits</a> &lt; float &gt;::One(). The absolute value of a Complex &lt; double &gt; is a <a class="el" href="structRVL_1_1ScalarFieldTraits.html" title="A traits class to extend the capabilities of numeric_limits without duplicating such capabilities...">RVL::ScalarFieldTraits</a> &lt; Complex &lt; double &gt; &gt; ::AbsType = double.  </p>
<p class="endli"></p>
</li>
<li>
<b>ProtectedDivision</b>: safeguarded division function template (<a class="el" href="namespaceRVL.html#a5e7beced6b8741d3583b4cb941b658ce" title="Calculate  in a careful manner. ">RVL::ProtectedDivision</a>), returns nonzero (true) if zerodivide occurs to floating precision.  </li>
</ul>
<p class="endli"></p>
</li>
<li>
<b>Operator new:</b> For reasons explained in the design paper, generally no need arises to dynamcially allocate instances of the critical calculus types - <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">RVL::Space</a>, <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">RVL::Vector</a>, <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">RVL::LinearOp</a>, <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a>, <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">RVL::FunctionalEvaluation</a>, <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">RVL::Operator</a>, and <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">RVL::OperatorEvaluation</a>. Therefore, operator new is by default protected (or, in one case, private) in these classes, and cannot be used except internally to the class and its close relatives (and in particular not in user code). However, it is conceivable that a case could arise in which dynamic allocation for one of these types is absolutely essential to accomplish some end, which simply cannot be attained using allocation on the stack. In view of this (unsubstantiated, as far as I know) possibility, <a class="el" href="namespaceRVL.html">RVL</a> 1.0 permits the user to enable the standard compiler-defined operator new. Simply uncomment the definition of RVL_OPERATOR_NEW_ENABLED in <a class="el" href="utility_8hh.html">rvl/rvl/include/utility.hh</a>, and install. </li>
</ul>
<hr/>
<p> <a href="../../../doc/html/index.html">RVL Home Page</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
