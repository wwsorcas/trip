<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>RVL: RVL Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RVL
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RVL Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1AdjLinearOp.html">AdjLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1AdjLinearOp.html" title="AdjLinearOp creates the adjoint operator of an LinearOp as a linear operator in its own right...">AdjLinearOp</a> creates the adjoint operator of an <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a> as a linear operator in its own right.  <a href="classRVL_1_1AdjLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ANLOperator.html">ANLOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator. ">ANLOperator</a> creates a nonlinear op from an affine operator.  <a href="classRVL_1_1ANLOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockFunctionObject.html">BlockFunctionObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BlockFOs are arrays of FOs, which can be evaluated block-diagonal fashion on ProductDCs.  <a href="classRVL_1_1BlockFunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockLinearOp.html">BlockLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> defined with product range.  <a href="classRVL_1_1BlockLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockLinearOpBlock.html">BlockLinearOpBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">i,j block of <a class="el" href="classRVL_1_1BlockLinearOp.html" title="Linear Operator defined with product range. ">BlockLinearOp</a>, as <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a>  <a href="classRVL_1_1BlockLinearOpBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockOperator.html">BlockOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> defined with product domain and range.  <a href="classRVL_1_1BlockOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1CartesianPowerSpace.html">CartesianPowerSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This space implements the Cartesian power of a space.  <a href="classRVL_1_1CartesianPowerSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ColumnLinearOp.html">ColumnLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> defined with product range.  <a href="classRVL_1_1ColumnLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1CompLinearOp.html">CompLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of linear operators <img class="formulaInl" alt="$ Op_1, Op_2 \mapsto Op_2 \circ Op_1 $" src="form_23.png"/> (so subscripts indicate order of evaluation - that's how the constructor is organized).  <a href="classRVL_1_1CompLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1CompLOVOp.html">CompLOVOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition in the first component of <a class="el" href="classRVL_1_1LinOpValOp.html" title="Operator with product domain presumed to be linear in last component, from which a linear operator ma...">LinOpValOp</a> with arbitrary op - could be accomplished with DiagonalOp, this construction introduced for efficiency's sake.  <a href="classRVL_1_1CompLOVOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Components.html">Components</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides indexed access to components (factors) of a <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">Vector</a> in <a class="el" href="classRVL_1_1ProductSpace.html" title="Abstract base class expressing behaviour of Cartesian products of vector spaces. ">ProductSpace</a>.  <a href="classRVL_1_1Components.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ConstLinOpValOp.html">ConstLinOpValOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linear operator F on x1, <a class="el" href="classRVL_1_1ConstLinOpValOp.html" title="Given a linear operator F on x1, ConstLinOpValOp provides a LinOpValOp where F is considered constant...">ConstLinOpValOp</a> provides a <a class="el" href="classRVL_1_1LinOpValOp.html" title="Operator with product domain presumed to be linear in last component, from which a linear operator ma...">LinOpValOp</a> where F is considered constant wrt x0.  <a href="classRVL_1_1ConstLinOpValOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DataContainer.html">DataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">DataContainer</a> is the principal <a class="el" href="namespaceRVL.html">RVL</a> abstraction for types encapsulating data structures.  <a href="classRVL_1_1DataContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DataContainerFactory.html">DataContainerFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Factory.html" title="Standard factory interface - really a policy. ">Factory</a> class for DataContainers.  <a href="classRVL_1_1DataContainerFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Deriv2Evaluation.html">Deriv2Evaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the 2nd derivative by delegating the implementation of the apply methods to the <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> class, by way of the Evaluation.  <a href="classRVL_1_1Deriv2Evaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DerivEvaluation.html">DerivEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the derivative by delegating the implementation of the apply methods to the <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> class, by way of the Evaluation.  <a href="classRVL_1_1DerivEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DiagonalFunctionObject.html">DiagonalFunctionObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces diagonal ("scalar") app of single FO to all components of ProductDC.  <a href="classRVL_1_1DiagonalFunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DiagOp.html">DiagOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit BlockOp construction for 2x2 diagonal.  <a href="classRVL_1_1DiagOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DynamicProduct.html">DynamicProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not-so-simple dynamically allocated product leverages presumed constructor that builds a T given a D and an index - fully defined class template  <a href="classRVL_1_1DynamicProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1EuclideanForm.html">EuclideanForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functional is the standard Euclidean Form <img class="formulaInl" alt="$f(x) = 0.5 |x|^{2}$" src="form_51.png"/>.  <a href="classRVL_1_1EuclideanForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Factory.html">Factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard factory interface - really a policy.  <a href="classRVL_1_1Factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FcnlOpComp.html">FcnlOpComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handle class creates the composite of a functional and an operator <img class="formulaInl" alt="$f(G(x))$" src="form_19.png"/>, using the protected services of <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> and <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">Functional</a>.  <a href="classRVL_1_1FcnlOpComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Functional.html">Functional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for scalar-valued vector functions.  <a href="classRVL_1_1Functional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalEvaluation.html">FunctionalEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation is a pair of a (clone of a) <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">Functional</a> and an evaluation point <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">Vector</a>, stored by reference.  <a href="classRVL_1_1FunctionalEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalProductDomain.html">FunctionalProductDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">Functional</a> which also has partial derivatives.  <a href="classRVL_1_1FunctionalProductDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalProductDomainEvaluation.html">FunctionalProductDomainEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">FunctionalEvaluation</a> which accesses the additional partial derivatives of the <a class="el" href="classRVL_1_1FunctionalProductDomain.html" title="A specialization of Functional which also has partial derivatives. ">FunctionalProductDomain</a> class.  <a href="classRVL_1_1FunctionalProductDomainEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObject.html">FunctionObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> / <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">DataContainer</a> hiearchy follows the Acyclic Visitor design pattern (see Martin 2002 for more on this).  <a href="classRVL_1_1FunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObjectConstEval.html">FunctionObjectConstEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Membership.  <a href="classRVL_1_1FunctionObjectConstEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObjectScalarRedn.html">FunctionObjectScalarRedn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object with const eval and scalar reduction attributes.  <a href="classRVL_1_1FunctionObjectScalarRedn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1HessianEvaluation.html">HessianEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hessian Evaluation is a lightweight implementation of the <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a> interface which refers back to a <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">FunctionalEvaluation</a> to implement all methods.  <a href="classRVL_1_1HessianEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1IdentityOp.html">IdentityOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator. ">IdentityOp</a> is a concrete class implementing identity operator.  <a href="classRVL_1_1IdentityOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1InjectOp.html">InjectOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine Injection operator.  <a href="classRVL_1_1InjectOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Invertible.html">Invertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Invertible.html" title="Invertible is a mixin interface for operators which can compute inverses. ">Invertible</a> is a mixin interface for operators which can compute inverses.  <a href="classRVL_1_1Invertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1InvertibleDerivEvaluation.html">InvertibleDerivEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of derivative supplied with inverse mappings.  <a href="classRVL_1_1InvertibleDerivEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LeastSquaresFcnlGN.html">LeastSquaresFcnlGN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LeastSquaresFcnlGN.html" title="LeastSquaresFcnlGN creates a least squares objective function from an operator. ">LeastSquaresFcnlGN</a> creates a least squares objective function from an operator.  <a href="classRVL_1_1LeastSquaresFcnlGN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombFunctional.html">LinCombFunctional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombFunctional.html" title="LinCombFunctional is a concrete class implementing a linear combination of two or more Functional ins...">LinCombFunctional</a> is a concrete class implementing a linear combination of two or more <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">Functional</a> instances.  <a href="classRVL_1_1LinCombFunctional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombLinearOp.html">LinCombLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombLinearOp.html" title="LinCombLinearOp is a concrete class implementing a linear combination with weights  of two linear ope...">LinCombLinearOp</a> is a concrete class implementing a linear combination with weights <img class="formulaInl" alt="$ w_1, w_2 $" src="form_29.png"/> of two linear operators <img class="formulaInl" alt="$ Op_1 $" src="form_30.png"/> and <img class="formulaInl" alt="$ Op_2 $" src="form_31.png"/>, that is, <img class="formulaInl" alt="$w_1 Op_1 + w_2 Op_2$" src="form_32.png"/>.  <a href="classRVL_1_1LinCombLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombObject.html">LinCombObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombObject.html" title="LinCombObject is an subtype FunctionObject offering a method to set two mutable scalars a and b...">LinCombObject</a> is an subtype <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> offering a method to set two mutable scalars a and b, intended to be coefficients in a linear combination.  <a href="classRVL_1_1LinCombObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombOperator.html">LinCombOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator</a> is a concrete class implementing a linear combination of two or more <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> instances.  <a href="classRVL_1_1LinCombOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCompLOVOp.html">LinCompLOVOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition in the second component of <a class="el" href="classRVL_1_1LinOpValOp.html" title="Operator with product domain presumed to be linear in last component, from which a linear operator ma...">LinOpValOp</a> with arbitrary lop - could be accomplished with DiagonalOp, this construction introduced for efficiency's sake.  <a href="classRVL_1_1LinCompLOVOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearAlgebraPackage.html">LinearAlgebraPackage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to function objects defining the basic ops of linear algebra in Hilbert space: linear combination, assignment to the zero vector, and inner product.  <a href="classRVL_1_1LinearAlgebraPackage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearBilinearOp.html">LinearBilinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a> crreated by fixing the first argument in a bilinear op.  <a href="classRVL_1_1LinearBilinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOp.html">LinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal <a class="el" href="namespaceRVL.html">RVL</a> interface for Linear Operators.  <a href="classRVL_1_1LinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpAdjEvaluation.html">LinearOpAdjEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another convenience handle class used in formulation of linear combination, composition algorithms to avoid unnecessary temporary storage and computation, which would result from using <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> in the same settings.  <a href="classRVL_1_1LinearOpAdjEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpEvaluation.html">LinearOpEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class used in formulation of linear combination, composition algorithms to avoid unnecessary temporary storage and computation, which would result from using <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> in the same settings.  <a href="classRVL_1_1LinearOpEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpFO.html">LinearOpFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a>, given spaces for domain and range and FunctionObjects implementing the forward and adjoint apply...  <a href="classRVL_1_1LinearOpFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpWithInverse.html">LinearOpWithInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operator with inverse mapping supplied as a class method.  <a href="classRVL_1_1LinearOpWithInverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearRestrictOp.html">LinearRestrictOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">create linear op by restricting the nonlinear variable in <a class="el" href="classRVL_1_1LinOpValOp.html" title="Operator with product domain presumed to be linear in last component, from which a linear operator ma...">LinOpValOp</a>.  <a href="classRVL_1_1LinearRestrictOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinOpValOp.html">LinOpValOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> with product domain presumed to be linear in last component, from which a linear operator may be conveniently extracted by restriction.  <a href="classRVL_1_1LinOpValOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LNLOperator.html">LNLOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator. ">LNLOperator</a> creates a nonlinear op from a linear operator.  <a href="classRVL_1_1LNLOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1NormalLinearOp.html">NormalLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1NormalLinearOp.html" title="NormalLinearOp creates the normal operator  of a LinearOp  as a linear operator in its own right...">NormalLinearOp</a> creates the normal operator <img class="formulaInl" alt="$ A^*A $" src="form_24.png"/> of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a> <img class="formulaInl" alt="$ A $" src="form_25.png"/> as a linear operator in its own right.  <a href="classRVL_1_1NormalLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1NullFunctional.html">NullFunctional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-functional.  <a href="classRVL_1_1NullFunctional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OpComp.html">OpComp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a> is a concrete class implementing composition of any number of <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> and/or <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a> instancess.  <a href="classRVL_1_1OpComp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Operator.html">Operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for vector-valued vector functions.  <a href="classRVL_1_1Operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorEvaluation.html">OperatorEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> pairs a reference to a <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">Vector</a> with an independent, dynamically-allocated instance of an <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a>.  <a href="classRVL_1_1OperatorEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorProductDomain.html">OperatorProductDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions. ">Operator</a> defined on product space.  <a href="classRVL_1_1OperatorProductDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorProductDomainEvaluation.html">OperatorProductDomainEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation for product domain case, provided only for type-safety.  <a href="classRVL_1_1OperatorProductDomainEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorWithInvertibleDeriv.html">OperatorWithInvertibleDeriv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators whose derivatives are supplied with inverse mappings.  <a href="classRVL_1_1OperatorWithInvertibleDeriv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OpFO.html">OpFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of an op, given spaces for domain and range and several <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> instances implementing the various apply operations: in the notation of the main constructor OpFO::OpFO, the first <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> argument (f) is used to implement <a class="el" href="classRVL_1_1OpFO.html#ad0c1f33df4fa60004595ecd81f7374d2">OpFO::apply</a>, the second (dff) to implement <a class="el" href="classRVL_1_1OpFO.html#a2dd1aae75d2c0db890577bef6b9d6ee8">OpFO::applyDeriv</a>, and the third (dfa) to implement <a class="el" href="classRVL_1_1OpFO.html#af2664a13c536daea29179e2a90511120">OpFO::applyAdjDeriv</a>.  <a href="classRVL_1_1OpFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic oracle interface.  <a href="classRVL_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1PartialDerivEvaluation.html">PartialDerivEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar in structure to <a class="el" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>  <a href="classRVL_1_1PartialDerivEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1PartialHessianEvaluation.html">PartialHessianEvaluation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Product.html">Product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Cartesian product mixin.  <a href="classRVL_1_1Product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ProductDataContainer.html">ProductDataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ProductDataContainers are DataContainers equipped with an indexing operator[], which returns a reference to a <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures. ">DataContainer</a> when supplied with an in-range int index.  <a href="classRVL_1_1ProductDataContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ProductSpace.html">ProductSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class expressing behaviour of Cartesian products of vector spaces.  <a href="classRVL_1_1ProductSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1QuadraticForm.html">QuadraticForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1QuadraticForm.html" title="QuadraticForm creates a function of the form  in which A is a linear operator. ">QuadraticForm</a> creates a function of the form <img class="formulaInl" alt="$ x \mapsto \frac{1}{2} |A x|^2 $" src="form_52.png"/> in which A is a linear operator.  <a href="classRVL_1_1QuadraticForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ResidualOperator.html">ResidualOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input vector d, and an operator G, this operator implements <img class="formulaInl" alt="$F(x) = G(x)-d$" src="form_50.png"/>.  <a href="classRVL_1_1ResidualOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1RestrictFcnl.html">RestrictFcnl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restriction operator - currently only for two-component domains.  <a href="classRVL_1_1RestrictFcnl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1RestrictOp.html">RestrictOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">restriction, or partial evaluation, of an operator on a product space.  <a href="classRVL_1_1RestrictOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ROProduct.html">ROProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Cartesian product mixin - read-only access to factors.  <a href="classRVL_1_1ROProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1RVLException.html">RVLException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the std::exception interface, with additional methods so it can be used more like a output stream.  <a href="classRVL_1_1RVLException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class to extend the capabilities of numeric_limits without duplicating such capabilities.  <a href="structRVL_1_1ScalarFieldTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01bool_01_4.html">ScalarFieldTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01double_01_4.html">ScalarFieldTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01float_01_4.html">ScalarFieldTraits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01int_01_4.html">ScalarFieldTraits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01long_01_4.html">ScalarFieldTraits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01std_1_1complex_3_01T_01_4_01_4.html">ScalarFieldTraits&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01unsigned_01int_01_4.html">ScalarFieldTraits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01unsigned_01long_01_4.html">ScalarFieldTraits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScalarRedn.html">ScalarRedn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin class for types that store, update, and return "small" objects, meaning effectively those with usable copy semantics.  <a href="classRVL_1_1ScalarRedn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScaleOpFwd.html">ScaleOpFwd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ScaleOpFwd.html" title="ScaleOpFwd implementing the linear operator  where a is a scalar. ">ScaleOpFwd</a> implementing the linear operator <img class="formulaInl" alt="$ x\mapsto ax $" src="form_26.png"/> where a is a scalar.  <a href="classRVL_1_1ScaleOpFwd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScaleOpInv.html">ScaleOpInv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ScaleOpInv.html" title="ScaleOpInv implementing the linear operator  where  is a scalar. ">ScaleOpInv</a> implementing the linear operator <img class="formulaInl" alt="$ x\mapsto \frac{1}{a}x $" src="form_28.png"/> where <img class="formulaInl" alt="$ a $" src="form_27.png"/> is a scalar.  <a href="classRVL_1_1ScaleOpInv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ShiftedQuadraticForm.html">ShiftedQuadraticForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ShiftedQuadraticForm.html" title="ShiftedQuadraticForm creates a function of the form  in which A is a linear operator, b a vector. ">ShiftedQuadraticForm</a> creates a function of the form <img class="formulaInl" alt="$ x \mapsto \frac{1}{2} |A x - b|^2 $" src="form_53.png"/> in which A is a linear operator, b a vector.  <a href="classRVL_1_1ShiftedQuadraticForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ShiftOperator.html">ShiftOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input vector d, this operator implements <img class="formulaInl" alt="$F(x) = x-d$" src="form_49.png"/>.  <a href="classRVL_1_1ShiftOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Space.html">Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRVL.html">RVL</a> abstract base class for Hilbert Spaces.  <a href="classRVL_1_1Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1SpaceDCF.html">SpaceDCF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A converse to <a class="el" href="classRVL_1_1StdSpace.html" title="Standard modular RVL space class. ">StdSpace</a>: takes any space and makes manifest its inner <a class="el" href="classRVL_1_1DataContainerFactory.html" title="Factory class for DataContainers. ">DataContainerFactory</a>.  <a href="classRVL_1_1SpaceDCF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdFOFunctional.html">StdFOFunctional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">Functional</a> interface by combining the operation of three FunctionObjects and a domain <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces. ">Space</a>.  <a href="classRVL_1_1StdFOFunctional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdLeastSquaresFcnlGN.html">StdLeastSquaresFcnlGN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1StdLeastSquaresFcnlGN.html" title="StdLeastSquaresFcnlGN creates a least squares objective function from an operator and a data vector...">StdLeastSquaresFcnlGN</a> creates a least squares objective function from an operator and a data vector.  <a href="classRVL_1_1StdLeastSquaresFcnlGN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdProductDataContainer.html">StdProductDataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard implementation of <a class="el" href="classRVL_1_1ProductDataContainer.html" title="ProductDataContainers are DataContainers equipped with an indexing operator[], which returns a refere...">ProductDataContainer</a>.  <a href="classRVL_1_1StdProductDataContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdProductSpace.html">StdProductSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of product spaces, via an (STL) vector of dynamically allocated Spaces.  <a href="classRVL_1_1StdProductSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdSpace.html">StdSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard modular <a class="el" href="namespaceRVL.html">RVL</a> space class.  <a href="classRVL_1_1StdSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1SymmetricBilinearOp.html">SymmetricBilinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">for the moment, a standalone class.  <a href="classRVL_1_1SymmetricBilinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1TangentMap.html">TangentMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard example of <a class="el" href="classRVL_1_1LinOpValOp.html" title="Operator with product domain presumed to be linear in last component, from which a linear operator ma...">LinOpValOp</a>: <img class="formulaInl" alt="$ (x,dx) \mapsto DF(x)dx$" src="form_62.png"/>  <a href="classRVL_1_1TangentMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1TensorLinearOp.html">TensorLinearOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit <a class="el" href="classRVL_1_1ColumnLinearOp.html" title="Linear Operator defined with product range. ">ColumnLinearOp</a> construction for two range components Y.H.  <a href="classRVL_1_1TensorLinearOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1TensorOp.html">TensorOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit BlockOp construction for two range components.  <a href="classRVL_1_1TensorOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRVL.html">RVL</a> <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class. ">Vector</a> class.  <a href="classRVL_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1WatchedVecRef.html">WatchedVecRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class references a vector and will store a version number.  <a href="classRVL_1_1WatchedVecRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Writeable.html">Writeable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin interface to mandate write-to-ostream method, and derive write-to-exception method from it.  <a href="classRVL_1_1Writeable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f4c54c14907a1a59176a38230bdd215"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4f4c54c14907a1a59176a38230bdd215"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a4f4c54c14907a1a59176a38230bdd215">AdjointTest</a> (<a class="el" href="classRVL_1_1LinearOp.html">LinearOp</a>&lt; Scalar &gt; const &amp;op, <a class="el" href="classRVL_1_1FunctionObject.html">FunctionObject</a> &amp;randomize, ostream &amp;str, int tol=100)</td></tr>
<tr class="memdesc:a4f4c54c14907a1a59176a38230bdd215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test of adjoint relationship between applyOp and applyAdjOp methods of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a>.  <a href="#a4f4c54c14907a1a59176a38230bdd215">More...</a><br /></td></tr>
<tr class="separator:a4f4c54c14907a1a59176a38230bdd215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fd266fc449300086fc5a142b16bcba"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a54fd266fc449300086fc5a142b16bcba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a54fd266fc449300086fc5a142b16bcba">DerivTest</a> (<a class="el" href="classRVL_1_1Operator.html">Operator</a>&lt; Scalar &gt; const &amp;op, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;y, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;p, ostream &amp;str, int n=10, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType hmin=0.1, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType hmax=1.0, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType minrat=1.95)</td></tr>
<tr class="memdesc:a54fd266fc449300086fc5a142b16bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests accuracy of directional derivative computation by comparison with centered finite difference approximation.  <a href="#a54fd266fc449300086fc5a142b16bcba">More...</a><br /></td></tr>
<tr class="separator:a54fd266fc449300086fc5a142b16bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5912f017113d3e671381e333e38d743"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:ab5912f017113d3e671381e333e38d743"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#ab5912f017113d3e671381e333e38d743">GradientTest</a> (<a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;f, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;y, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;p, ostream &amp;str, int n=11, Scalar hmin=0.1, Scalar hmax=1.0, Scalar minrat=1.95)</td></tr>
<tr class="memdesc:ab5912f017113d3e671381e333e38d743"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation of the gradient test should be sufficient for all Functionals.  <a href="#ab5912f017113d3e671381e333e38d743">More...</a><br /></td></tr>
<tr class="separator:ab5912f017113d3e671381e333e38d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718240d9213bb6f2393a2556eabf38e"><td class="memTemplParams" colspan="2">template&lt;typename MetaType &gt; </td></tr>
<tr class="memitem:a4718240d9213bb6f2393a2556eabf38e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a4718240d9213bb6f2393a2556eabf38e">getDataSize</a> (MetaType const &amp;md)</td></tr>
<tr class="memdesc:a4718240d9213bb6f2393a2556eabf38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function template to extract the size of a data array implicit in a MetaType object.  <a href="#a4718240d9213bb6f2393a2556eabf38e">More...</a><br /></td></tr>
<tr class="separator:a4718240d9213bb6f2393a2556eabf38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81def3aac48080aee95fdc7ca91ec4bc"><td class="memTemplParams" colspan="2">template&lt;class MetaType &gt; </td></tr>
<tr class="memitem:a81def3aac48080aee95fdc7ca91ec4bc"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a81def3aac48080aee95fdc7ca91ec4bc">getMetaSize</a> (MetaType const &amp;md)</td></tr>
<tr class="memdesc:a81def3aac48080aee95fdc7ca91ec4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata types are not constant sized, so serialization requires a size function.  <a href="#a81def3aac48080aee95fdc7ca91ec4bc">More...</a><br /></td></tr>
<tr class="separator:a81def3aac48080aee95fdc7ca91ec4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c248aea14e2b1280af6008324915a4e"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a1c248aea14e2b1280af6008324915a4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a1c248aea14e2b1280af6008324915a4e">Scan</a> (<a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;f, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;y, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;p, int n=11, Scalar hmin=-<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::One(), Scalar hmax=<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::One(), ostream &amp;str=cout)</td></tr>
<tr class="memdesc:a1c248aea14e2b1280af6008324915a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes values of an <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> along a line segment in its domain, and writes them nicely formatted to an output stream.  <a href="#a1c248aea14e2b1280af6008324915a4e">More...</a><br /></td></tr>
<tr class="separator:a1c248aea14e2b1280af6008324915a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36714a2429f8ae2d8c292241918015"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afa36714a2429f8ae2d8c292241918015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#afa36714a2429f8ae2d8c292241918015">SpaceTest</a> (<a class="el" href="classRVL_1_1Space.html">Space</a>&lt; Scalar &gt; const &amp;sp, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;v, std::string msg)</td></tr>
<tr class="memdesc:afa36714a2429f8ae2d8c292241918015"><td class="mdescLeft">&#160;</td><td class="mdescRight">space membership test - turns standard test into one-liner  <a href="#afa36714a2429f8ae2d8c292241918015">More...</a><br /></td></tr>
<tr class="separator:afa36714a2429f8ae2d8c292241918015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9553ebb5a1dfe83a513ff453a70e9ca"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac9553ebb5a1dfe83a513ff453a70e9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#ac9553ebb5a1dfe83a513ff453a70e9ca">testRealOnly</a> ()</td></tr>
<tr class="memdesc:ac9553ebb5a1dfe83a513ff453a70e9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some applications do not make sense unless the absolute value type (signed, in the current implementation) is the same as the scalar type.  <a href="#ac9553ebb5a1dfe83a513ff453a70e9ca">More...</a><br /></td></tr>
<tr class="separator:ac9553ebb5a1dfe83a513ff453a70e9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7beced6b8741d3583b4cb941b658ce"><td class="memTemplParams" colspan="2">template&lt;class real &gt; </td></tr>
<tr class="memitem:a5e7beced6b8741d3583b4cb941b658ce"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a5e7beced6b8741d3583b4cb941b658ce">ProtectedDivision</a> (real a, real b, real &amp;quot, real tol=<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; real &gt;::AbsZero())</td></tr>
<tr class="memdesc:a5e7beced6b8741d3583b4cb941b658ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <img class="formulaInl" alt="$quot = a/b$" src="form_84.png"/> in a careful manner.  <a href="#a5e7beced6b8741d3583b4cb941b658ce">More...</a><br /></td></tr>
<tr class="separator:a5e7beced6b8741d3583b4cb941b658ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4f4c54c14907a1a59176a38230bdd215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RVL::AdjointTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRVL_1_1LinearOp.html">LinearOp</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRVL_1_1FunctionObject.html">FunctionObject</a> &amp;&#160;</td>
          <td class="paramname"><em>randomize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tol</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test of adjoint relationship between applyOp and applyAdjOp methods of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators. ">LinearOp</a>. </p>
<p>constructs random vectors x in domain, y in range, applies image method to x, adjoint image method to y, and compares inner products. </p>

<p>Definition at line <a class="el" href="adjtest_8hh_source.html#l00046">46</a> of file <a class="el" href="adjtest_8hh_source.html">adjtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a54fd266fc449300086fc5a142b16bcba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RVL::DerivTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Operator.html">Operator</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>hmax</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>minrat</em> = <code>1.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests accuracy of directional derivative computation by comparison with centered finite difference approximation. </p>
<p>Prints several columns of output, including estimated convergence rate, which should approach 2. Since no unversal scale rule is possible, users will have to adjust the limits hmin and hmax to suit the application.</p>
<p>Arguments: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator whose deriv comp is to be tested </td></tr>
    <tr><td class="paramname">y</td><td>base point at which derivative accuracy is tested </td></tr>
    <tr><td class="paramname">dy</td><td>direction of differentiation </td></tr>
    <tr><td class="paramname">str</td><td>output stream on which to print report (use cout for terminal output) </td></tr>
    <tr><td class="paramname">n</td><td>number of (evenly spaced) offsets h at which to compute divided differences. Default is 10. </td></tr>
    <tr><td class="paramname">hmin</td><td>minimum offset (default 0.1) </td></tr>
    <tr><td class="paramname">hmax</td><td>maximum offset (defaults 1.0, but these defaults are only useful if the operator is rather smooth in the intrinsic scale of <img class="formulaInl" alt="$y$" src="form_9.png"/>).  rate of convergence lower bound - test returns true if the last convergence rate computed is lower than this one (i.e. "yes there is a problem"), else false ("no problem").</td></tr>
  </table>
  </dd>
</dl>
<p>Denoting the operator by <img class="formulaInl" alt="$F$" src="form_10.png"/>, the test computes <img class="formulaInl" alt="$DF(y)dy$" src="form_11.png"/>, and compares it to the divided difference <img class="formulaInl" alt="$G(h) = (F(y+h*dy)-F(y-h*dy))/(2*h)$" src="form_12.png"/>, where <img class="formulaInl" alt="$h = hmin + i*dh, dh = (hmax-hmin)/(n-1)$" src="form_13.png"/> for <img class="formulaInl" alt="$i=0,...,n-1$" src="form_14.png"/>. The estimated convergence rate of the divided differences to the derivative is <img class="formulaInl" alt="$\log(\|G(h+dh)-(h+dh)*DF(y)dy\|/\|G(h)-h*DF(y)dy\|)/ \log((h+dh)/h)$" src="form_15.png"/>, which should approach 2 as <img class="formulaInl" alt="$h \rightarrow 0$" src="form_16.png"/>. </p>

<p>Definition at line <a class="el" href="derivtest_8hh_source.html#l00074">74</a> of file <a class="el" href="derivtest_8hh_source.html">derivtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ab5912f017113d3e671381e333e38d743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RVL::GradientTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmax</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>minrat</em> = <code>1.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implementation of the gradient test should be sufficient for all Functionals. </p>
<p>Tests n finite difference steps from y in direction p, ranging from hmin to hmax. Compares computed rate of change &lt;grad f(y), p&gt; with centered finite difference approximations (f(y+h*p)-f(y-h*p))/(2*h) for n values of h ranging from hmin to hmax. Computes nominal convergence rate by Richardson extrapolation, prints result to ostream specified in arg list. Convergence rate should converge to 2.0 for well-chosen n, range of steps h. </p>

<p>Definition at line <a class="el" href="gradtest_8hh_source.html#l00051">51</a> of file <a class="el" href="gradtest_8hh_source.html">gradtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a4718240d9213bb6f2393a2556eabf38e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MetaType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t RVL::getDataSize </td>
          <td>(</td>
          <td class="paramtype">MetaType const &amp;&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function template to extract the size of a data array implicit in a MetaType object. </p>
<p>No sensible default, so throws exception. Specializations provided for intrinsic integer MetaType (size_t, int, long, uint,...). Note - returns size of data in WORDS - DataType not being specified cannot convert to bytes here. </p>

<p>Definition at line <a class="el" href="product_8hh_source.html#l00083">83</a> of file <a class="el" href="product_8hh_source.html">product.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a81def3aac48080aee95fdc7ca91ec4bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MetaType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t RVL::getMetaSize </td>
          <td>(</td>
          <td class="paramtype">MetaType const &amp;&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metadata types are not constant sized, so serialization requires a size function. </p>
<p>Obvious specializations supplied for int types. note that return is size in BYTES. </p>

<p>Definition at line <a class="el" href="product_8hh_source.html#l00094">94</a> of file <a class="el" href="product_8hh_source.html">product.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a1c248aea14e2b1280af6008324915a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::Scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>-<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt;Scalar&gt;::One()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmax</em> = <code><a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt;Scalar&gt;::One()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes values of an <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions. ">RVL::Functional</a> along a line segment in its domain, and writes them nicely formatted to an output stream. </p>

<p>Definition at line <a class="el" href="scantest_8hh_source.html#l00044">44</a> of file <a class="el" href="scantest_8hh_source.html">scantest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="afa36714a2429f8ae2d8c292241918015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::SpaceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Space.html">Space</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>space membership test - turns standard test into one-liner </p>

<p>Definition at line <a class="el" href="space_8hh_source.html#l00945">945</a> of file <a class="el" href="space_8hh_source.html">space.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ac9553ebb5a1dfe83a513ff453a70e9ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::testRealOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some applications do not make sense unless the absolute value type (signed, in the current implementation) is the same as the scalar type. </p>
<p>Including a call to this function anywhere in the code defining a class will ensure that it compiles only when this "reality" condition is satisfied. </p>

<p>Definition at line <a class="el" href="utility_8hh_source.html#l00195">195</a> of file <a class="el" href="utility_8hh_source.html">utility.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a5e7beced6b8741d3583b4cb941b658ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RVL::ProtectedDivision </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real &amp;&#160;</td>
          <td class="paramname"><em>quot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt;real&gt;::AbsZero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <img class="formulaInl" alt="$quot = a/b$" src="form_84.png"/> in a careful manner. </p>
<p>Without the tolerance, performs checks to avoid underflow/overflow. With the tolerance, checks to ensure that the resulting quotient exceeds the tolerance. Return codes: 1 Overflow 2 Underflow 3 Failed to exceed specified tolerance. </p>

<p>Definition at line <a class="el" href="utility_8hh_source.html#l00212">212</a> of file <a class="el" href="utility_8hh_source.html">utility.hh</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
