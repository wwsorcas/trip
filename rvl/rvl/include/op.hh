/*************************************************************************

Copyright Rice University, 2004-2015.
All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, provided that the above copyright notice(s) and this
permission notice appear in all copies of the Software and that both the
above copyright notice(s) and this permission notice appear in supporting
documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder shall
not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization of the
copyright holder.

**************************************************************************/

#ifndef __RVL_OP
#define __RVL_OP

#include "space.hh"
#include "linop_base.hh"
#include "productspace.hh"
#include "write.hh"

namespace RVL {

  // forward declarations required for extra-class friendships
  
  template<class Scalar> 
  class OperatorEvaluation;

  template<class Scalar> 
  class DerivEvaluation;

  template<class Scalar> 
  class Deriv2Evaluation;

  template<class Scalar>
  class OpComp;

  template<class Scalar>
  class FcnlOpComp;

  /** Interface for vector-valued vector functions. Current version 
      provides only first derivatives - higher derivatives may be 
      added later. 

      This interface has virtually no public members, other than those
      which idenify its domain and range. The action happens in the
      protected member functions. These get used by the Evaluation
      classes to initialize the various values (of the function
      itself, its derivatives, etc.) and any intermediate data on
      which these might depend. The Operator::clone method (virtual
      copy constructor) is also protected, and is used by the
      Evaluation constructor to create a completely independent copy.

      As is the case with other core RVL classes, Operators are
      intended to be allocated on the stack. Therefore
      Operator::new is overridden as a protected method, to
      be used by concrete child classes to define Operator::clone.

      Concrete subclasses of Operator should be written in "use-once"
      style: any and all internal data should be written once and
      treated as read-only thereafter. The only functions which might
      change an Operator instance's internal state are protected, and
      accessible only through OperatorEvaluation value access methods
      (such as OperatorEvaluation::getValue). All internal data
      generated by an instance is therefore tied to a particular
      evaluation point, and automatically remains consistent for the
      lifetime of the object. No consistency checks are required.

      Since OperatorEvaluation objects clone Operator instances,
      efficient implementations will typically allocate as much
      internal storage as possible dynamically, and only at the point
      of use. For example an array foo of length n used in the apply
      method would be initialized in the constructor as a pointer to
      NULL then reinitialized at the point of use: const void
      apply(...) { ...  if (!foo) foo = new Scalar[n]; ...  }.

      A unit test for validity of the derivative computation is
      supplied as part of RVL, in the form of a standalone function
      (DerivTest). It is HIGHLY RECOMMENDED that every concrete
      Operator implementation be subjected to this test, and that the
      computed derivative returned by OperatorEvaluation::getDeriv be
      subjected to the adjoint test (standalone function AdjointTest).

      Finally, this version of Operator presumes that the values
      produced are of the same type as the input, that is, the
      template parameter Scalar describes the scalar field of both the
      input vector and the output vector. The class is not a suitable
      abstraction for real vector-valued functions of complex vector
      variables, for instance.
  */

  template<class Scalar> 
  class Operator: public Writeable {

    friend class OperatorEvaluation<Scalar>;
    friend class FcnlOpComp<Scalar>; 

  protected:

    /** 1-jet at a point, accessible only through OperatorEvaluation
	and subclasses.
    */

    /** \f$y = F(x)\f$ */
    virtual void apply(const Vector<Scalar> & x, 
		       Vector<Scalar> & y) const = 0;

    /** \f$dy = DF(x)dx\f$ */
    virtual void applyDeriv(const Vector<Scalar> & x, 
			    const Vector<Scalar> & dx,
			    Vector<Scalar> & dy) const = 0;

    /** \f$dx = DF(x)^*dy\f$ */
    virtual void applyAdjDeriv(const Vector<Scalar> & x, 
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx) const = 0;

    /* \f$ dy=D^2F(x)(dx_0,dx_1) \f$
       implemented to throw exception - override in subclasses 
       that need 2nd deriv.
    */
    virtual void applyDeriv2(const Vector<Scalar> &, 
			     const Vector<Scalar> &,
			     const Vector<Scalar> &,
			     Vector<Scalar> &) const {
      RVLException e;
      e<<"Error: Operator::applyDeriv2 not implemented\n";
      throw e;
    }

    /** \f$dx_1 = D^2F(x)^*(dx_0,dy)\f$, defined so that
     \f$\langle D^2F(x)^*(dx_0,dy),dx_1\rangle_X = \langle dy, D^2F(x)(dx_0,dx_1) \f$.
     Note that this form should be symmetric, so the other possible definition of adjoint
     yields the same result.

     implemented to throw exception - override in subclasses that need 2nd deriv.
    */
    virtual void applyAdjDeriv2(const Vector<Scalar> &,
				const Vector<Scalar> &,
				const Vector<Scalar> &,
				Vector<Scalar> &) const {
      RVLException e;
      e<<"Error: Operator::applyAdjDeriv2 not implemented\n";
      throw e;
    }

    /** The export-apply methods make the protected apply methods 
	of any Operator subclass instance available to other 
	Operator subclass instances. */

    static void export_apply(Operator<Scalar> const & f,
			     const Vector<Scalar> & x,
			     Vector<Scalar> & y) {
      f.apply(x,y);
    }

    static void export_applyDeriv(Operator<Scalar> const & f,
				  const Vector<Scalar> & x,
				  const Vector<Scalar> & dx,
				  Vector<Scalar> & dy) {
      f.applyDeriv(x,dx,dy);
    }

    static void export_applyAdjDeriv(Operator<Scalar> const & f,
				     const Vector<Scalar> & x,
				     const Vector<Scalar> & dy,
				     Vector<Scalar> & dx) {
      f.applyAdjDeriv(x,dy,dx);
    }

    static void export_applyDeriv2(Operator<Scalar> const & f,
				   const Vector<Scalar> & x,
				   const Vector<Scalar> & dx0,
				   const Vector<Scalar> & dx1,
				   Vector<Scalar> & dy) {
      f.applyDeriv2(x,dx0,dx1,dy);
    }

    static void export_applyAdjDeriv2(Operator<Scalar> const & f,
				      const Vector<Scalar> & x,
				      const Vector<Scalar> & dx0,
				      const Vector<Scalar> & dy,
				      Vector<Scalar> & dx1) {
      f.applyAdjDeriv2(x,dx0,dy,dx1);
    }

    /** operator new - not available to general public, but
	available to children who will use it to define clone 

	Version 1.0: user control, for those who believe it's not just
	for children.
    */

#ifndef RVL_OPERATOR_NEW_ENABLED
    void * operator new(size_t size) { 
      void * ptr;
      ptr = (void *) ::new unsigned char[size]; 
      return ptr;
    }
#endif

    /** virtual copy contructor, also accessible only through
	OperatorEvaluation. Usually implemented with operator new and
	copy constructor of concrete child class. */

    virtual Operator<Scalar> * clone() const = 0;

    /** export version of clone */
    static Operator<Scalar> * export_clone(Operator<Scalar> const & op) {
      return op.clone();
    }
    
    /** Virtual derivative constructor.  Permits subclasses to implement the 
	derivative linear op with additional functionality using a subclass of
	DerivEvaluation instead of the simplest form.
    */
    DerivEvaluation<Scalar> * 
    createDerivEvaluation(OperatorEvaluation<Scalar> & opeval) const {
      return new DerivEvaluation<Scalar>(opeval);
    }

    /** Virtual 2nd derivative constructor.  Permits subclasses to
	implement the 2nd derivative bilinear op with additional
	functionality using a subclass of Deriv2Evaluation instead of
	the simplest form.
    */
    Deriv2Evaluation<Scalar> * 
    createDeriv2Evaluation(OperatorEvaluation<Scalar> & opeval) const {
      return new Deriv2Evaluation<Scalar>(opeval);
    }

  public:

    using Writeable::write;

    Operator() {}
    Operator(const Operator<Scalar> &) {}
    virtual ~Operator() {}

    /** access to domain, range */
    virtual const Space<Scalar> & getDomain() const = 0;
    virtual const Space<Scalar> & getRange() const = 0;

    /** safe dynamic copy construction */
    static std::shared_ptr<Operator<Scalar> > clonePtr(Operator<Scalar> const & op) {
      std::shared_ptr<Operator<Scalar> > p(RVL::Operator<Scalar>::export_clone(op));
      return p;
    }

    /** can be overridden to express distance to boundary of
	domain for operators whose domains are not the whole space. 
	First arg: position, second arg: direction
    */
    virtual typename ScalarFieldTraits<Scalar>::AbsType 
    getMaxStep(const Vector<Scalar> &,
	       const Vector<Scalar> &) const {
      return numeric_limits<typename ScalarFieldTraits<Scalar>::AbsType>::max();
    }

  };

  template<class Scalar>
  class OperatorProductDomainEvaluation;

  template<class Scalar>
  class PartialDerivEvaluation;

  template<class Scalar>
  class RestrictOp;

  /** Operator defined on product space. Partial derivatives are
      defined, as is access to the domain as a ProductSpace.  As for
      the parent class, all functions which may change the internal
      state are protected, accessed only by the corresponding
      OperatorProductDomainEvaluation objects, which act on
      independent captive instances.
  */
  template<class Scalar> 
  class OperatorProductDomain: public Operator<Scalar> {

    friend class OperatorEvaluation<Scalar>;
    friend class RestrictOp<Scalar>;

  protected:

    /** \f$dy = \partial_iF(x)dx_i\f$, where \f$dx_i \in X_i\f$ */
    virtual void applyPartialDeriv(int i,
				   const Vector<Scalar> & x, 
				   const Vector<Scalar> & dxi,
				   Vector<Scalar> & dy) const = 0;
  
    /** applyDeriv() is implemented in terms of
	applyPartialDeriv(). Default implementation supplied, which
	may be overridden. 
    */
    virtual void applyDeriv(const Vector<Scalar> & x, 
			    const Vector<Scalar> & dx,
			    Vector<Scalar> & dy) const {
      try {
	Components<Scalar> dxc(dx);
	applyPartialDeriv(0,x,dxc[0],dy);
	Vector<Scalar> tmp(dy);
	for (int i=1; i<dxc.getSize(); i++) {
	  applyPartialDeriv(i,x,dxc[i],tmp);
	  dy.linComb(1.0,tmp);
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::applyDeriv\n";
	throw e;
      }
    }

    /** \f$dx_i = \partial_iF(x)^*dy\f$, where \f$dx_i \in X_i\f$ */
    virtual void applyAdjPartialDeriv(int i,
				      const Vector<Scalar> & x, 
				      const Vector<Scalar> & dy,
				      Vector<Scalar> & dxi) const = 0;

    /** applyAdjDeriv() is implemented in terms of
	applyAdjPartialDeriv(). Default implementation supplied, which
	may be overridden. */
    virtual void applyAdjDeriv(const Vector<Scalar> & x, 
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx) const {
      try {
	Components<Scalar> dxc(dx);
	for (int i=0; i<dxc.getSize(); i++) {
	  applyAdjPartialDeriv(i,x,dy,dxc[i]);
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::applyAdjDeriv\n";
	throw e;
      }
    }

    /** \f$dy = \partial^2_{i,j}F(x)(dx_i,dx_j)\f$, where \f$dx_i \in
     X_i, dx_j \in X_j\f$ NOTE: as is the case for applyDeriv2,
     default implementation is supplied and throws exception. */
    virtual void applyPartialDeriv2(int i, int j,
				    const Vector<Scalar> & x, 
				    const Vector<Scalar> & dxi,
				    const Vector<Scalar> & dxj,
				    Vector<Scalar> & dy) const {
      RVLException e;
      e<<"ERROR: no override for applyPartialDeriv2 supplied for \n";
      e<<"OperatorProductDomain:\n";
      this->write(e);
      throw e;
    }

    /** applyDeriv2() is implemented in terms of
	applyPartialDeriv2(). Default implementation supplied, which
	may be overridden. 
    */    
    virtual void applyDeriv2(const Vector<Scalar> & x, 
			     const Vector<Scalar> & dx0,
			     const Vector<Scalar> & dx1,
			     Vector<Scalar> & dy) const {
      try {
	Components<Scalar> cdx0(dx0);
	Components<Scalar> cdx1(dx1);
	dy.zero();
	Vector<Scalar> tmp(this->getRange());
	int dim = (this->getProductDomain()).getSize();
	for (int i=0; i<dim; i++) {
	  for (int j=0; j<dim; j++) {
	    this->applyPartialDeriv2(i,j,x,cdx0[i],cdx1[j],tmp);
	    dy.linComb(1.0,tmp);
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::applyDeriv2\n";
	throw e;
      }
    }

    /** \f$dx_i = \partial^2_{i,j}F(x)^*(dy,dx_j)\f$, where \f$dx_i
     \in X_i, dx_j \in X_j\f$ NOTES: (1) adjoint of linear map \f$X_i
     \rightarrow Y$ defined by $dx_i \mapsto
     \partial^2_{i,j}F(x)(dx_i,dx_j)\f$ (2) as is the case for
     applyDeriv2, default implementation is supplied and throws
     exception. */
    virtual void applyAdjPartialDeriv2(int i, int j,
				       const Vector<Scalar> & x, 
				       const Vector<Scalar> & dy,
				       const Vector<Scalar> & dxj,
				       Vector<Scalar> & dxi) const {
      RVLException e;
      e<<"ERROR: no override for applyAdjPartialDeriv2 supplied for \n";
      e<<"OperatorProductDomain:\n";
      this->write(e);
      throw e;
    }

    /** applyAdjDeriv2() is implemented in terms of
	applyAdjPartialDeriv2(). Default implementation supplied, which
	may be overridden. 
    */    
    virtual void applyAdjDeriv2(const Vector<Scalar> & x, 
				const Vector<Scalar> & dy,
				const Vector<Scalar> & dx1,
				Vector<Scalar> & dx0) const {
      try {
	Components<Scalar> cdx0(dx0);
	Components<Scalar> cdx1(dx1);
	dx0.zero();
	Vector<Scalar> tmp(this->getDomain());
	Components<Scalar> ctmp(tmp);
	int dim = (this->getProductDomain()).getSize();
	for (int i=0; i<dim; i++) {
	  for (int j=0; j<dim; j++) {
	    this->applyAdjPartialDeriv2(i,j,x,dy,cdx1[j],ctmp[i]);
	    cdx0[i].linComb(1.0,ctmp[i]);
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::applyAdjDeriv2\n";
	throw e;
      }
    }

    static void export_applyPartialDeriv(OperatorProductDomain<Scalar> const & f,
					 int i,
					 const Vector<Scalar> & x,
					 const Vector<Scalar> & dxi,
					 Vector<Scalar> & dy) {
      try {
	f.applyPartialDeriv(i,x,dxi,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::export_applyPartialDeriv\n";
	throw e;
      }
    }

    static void export_applyAdjPartialDeriv(OperatorProductDomain<Scalar> const & f,
					    int i,
					    const Vector<Scalar> & x,
					    const Vector<Scalar> & dy,
					    Vector<Scalar> & dxi) {
      try {
	f.applyAdjPartialDeriv(i,x,dy,dxi);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::export_applyAdjPartialDeriv\n";
	throw e;
      }
    }

    static void export_applyPartialDeriv2(OperatorProductDomain<Scalar> const & f,
					  int i, int j,
					  const Vector<Scalar> & x,
					  const Vector<Scalar> & dxi,
					  const Vector<Scalar> & dxj,
					  Vector<Scalar> & dy) {
      try {
	f.applyPartialDeriv2(i,j,x,dxi,dxj,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::export_applyPartialDeriv2\n";
	throw e;
      }
    }

    static void export_applyAdjPartialDeriv2(OperatorProductDomain<Scalar> const & f,
					     int i, int j,
					     const Vector<Scalar> & x,
					     const Vector<Scalar> & dy,
					     const Vector<Scalar> & dxj,
					     Vector<Scalar> & dxi) {
      try {
	f.applyAdjPartialDeriv2(i,j,x,dy,dxj,dxi);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomain::export_applyAdjPartialDeriv2\n";
	throw e;
      }
    }

    /** Primary clone method returns object of this type;
	parent clone method delegates. */
    virtual OperatorProductDomain<Scalar> * clonePD() const = 0;
    Operator<Scalar> * clone() const { return clonePD(); }

  public:

    OperatorProductDomain() {}
    OperatorProductDomain(const OperatorProductDomain<Scalar> &) {}
    virtual ~OperatorProductDomain() {}
   
    /** access to domain as ProductSpace */
    virtual const ProductSpace<Scalar> & getProductDomain() const = 0;
    /** access to domain as Space - delegates to getProductDomain */
    const Space<Scalar> & getDomain() const { 
      return getProductDomain(); 
    }
  
  };

  /** restriction, or partial evaluation, of an operator on a product
      space. At the moment limited fixing all but one factor of domain.
  */

  template<typename Scalar>
  class RestrictOp: public Operator<Scalar> {

  private: 

    // reference OPD
    OperatorProductDomain<Scalar> const & ff;
    // fixed vector - in domain, all but ith component fixed
    mutable Vector<Scalar> xx;
    // components of x
    mutable Components<Scalar> cxx;
    // index of domain space
    int i;
    
    RestrictOp();

  protected:

    void apply(Vector<Scalar> const & x,
	       Vector<Scalar> & y) const {
      try {
	cxx[i].copy(x);
	RVL::OperatorProductDomain<Scalar>::export_apply(ff, xx, y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::apply\n";
	throw e;
      }
    }

    void applyDeriv(Vector<Scalar> const & x,
		    Vector<Scalar> const & dx,
		    Vector<Scalar> & dy) const {
      try {
	cxx[i].copy(x);
	RVL::OperatorProductDomain<Scalar>::export_applyPartialDeriv(ff, i, xx, dx, dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(Vector<Scalar> const & x,
		       Vector<Scalar> const & dy,
		       Vector<Scalar> & dx) const {
      try {
	cxx[i].copy(x);
	RVL::OperatorProductDomain<Scalar>::export_applyAdjPartialDeriv(ff, i, xx, dy, dx);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::applyAdjDeriv\n";
	throw e;
      }
    }

    void applyDeriv2(Vector<Scalar> const & x,
		     Vector<Scalar> const & dx0,
		     Vector<Scalar> const & dx1,
		     Vector<Scalar> & dy) const {
      try {
	cxx[i].copy(x);
	RVL::OperatorProductDomain<Scalar>::export_applyPartialDeriv2(ff, i, i, xx, dx0, dx1, dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv2(Vector<Scalar> const & x,
			Vector<Scalar> const & dy,
			Vector<Scalar> const & dx1,
			Vector<Scalar> & dx0) const {
      try {
	cxx[i].copy(x);
	RVL::OperatorProductDomain<Scalar>::export_applyAdjPartialDeriv2(ff, i,i, xx, dy, dx1, dx0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::applyAdjDeriv\n";
	throw e;
      }
    }

    Operator<Scalar> * clone() const { 
      return new RestrictOp(*this);
    }
    
  public:

    /** main constructor: 
	@param _f = operaator to be restricted
	@param _x = vector in domain, all components except ith to be fixed
	@param _i = index of domain space of restriction
    */
    RestrictOp(OperatorProductDomain<Scalar> const & _f,
	       Vector<Scalar> const & x0, int _i) 
      : ff(_f), xx(_f.getDomain()), cxx(xx), i(_i) {
      try {
	xx.copy(x0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp constructor\n";
	//#ifdef IWAVE_USE_MPI
	//	int rk;
	//	MPI_Comm_rank(MPI_COMM_WORLD,&rk);
	//	if (rk==0) {
	  e<<"  copy x0 to xx:\n";
	  e<<"  x0 in space:\n";
	  x0.getSpace().write(e);
	  e<<"  xx in space:\n";
	  xx.getSpace().write(e);
	  //	}
	  //#endif
	throw e;
      }
    }

    RestrictOp(RestrictOp<Scalar> const & g): ff(g.ff), xx(g.xx), cxx(xx), i(g.i) {}

    ~RestrictOp() {}

    Space<Scalar> const & getDomain() const { return ff.getProductDomain()[i]; }
    Space<Scalar> const & getRange() const { return ff.getRange(); }

    Scalar getMaxStep(const Vector<Scalar> & x,
		      const Vector<Scalar> & dx) const {
      try {
	// as usual this doesn't really make sense
	cxx[i].copy(x);
	Vector<Scalar> dxx(ff.getDomain(),true);
	Components<Scalar> cdxx(dxx);
	cdxx[i].copy(dx);
	return ff.getMaxStep(xx,dxx);
      }
      catch (RVLException & e) {
	e<<"\ncalled from RestrictOp::getMaxStep\n";
	throw e;
      }
    }

    ostream & write(ostream & str) const {
      str<<"RestrictOp on domain subspace index "<<i<<" with\n";
      str<<"  Vector (for fixed components):\n";
      xx.write(str);
      str<<"  OpProdDom:\n";
      ff.write(str);
      return str;
    }
  };

  template<typename Scalar>
  class LinearRestrictOp;
  
  /** Operator with product domain presumed to be linear in last
      component, from which a linear operator may be conveniently
      extracted by restriction. The only essential additional
      attribute is an adjoint application method for the last
      component. Currently restricted to two components (either or
      both of which may themselves be products of course). Concrete
      implementations of some methods provided.

      In comments below will write \f$ F(x_0)x_1\f$ rather than \f$
      F(x_0,x_1) \f$ to emphasize assumed linearity of \f$F\f$ in 2nd
      arg.
   */
  template<class Scalar>
  class LinOpValOp: public OperatorProductDomain<Scalar> {

    friend class LinearRestrictOp<Scalar>;
    
  protected:

    /** \f$y = F(x_0)x_1\f$ */
    virtual void apply0(const Vector<Scalar> & x0,
			const Vector<Scalar> & x1, 
			Vector<Scalar> & y) const = 0;
    
    /** \f$x_1 = F^*(x_0)y\f$ = adjoint of \f$x_1 \rightarrow F(x_0)x_1\f$ */
    virtual void applyAdj0(const Vector<Scalar> & x0,
			   const Vector<Scalar> & y, 
			   Vector<Scalar> & x1) const = 0;

    /** \f$dx_0 = (DF(x_0)dx_0)x_1\f$ */
    virtual void applyPartialDeriv0(const Vector<Scalar> & x0,
				    const Vector<Scalar> & x1,
				    const Vector<Scalar> & dx0,
				    Vector<Scalar> & dy) const = 0;

    /** adjoint of \f$dx_0 \rightarrow (DF(x_0)dx_0)x_1\f$ */
    virtual void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
				       const Vector<Scalar> & x1,
				       const Vector<Scalar> & dy,
				       Vector<Scalar> & dx0) const = 0;

    /** adjoint of \f$x_1 \rightarrow (DF(x_0)dx_0)x_1\f$ needed in
	definition of 2nd deriv */
    virtual void applyAdjPartialDeriv1(const Vector<Scalar> & x0,
				       const Vector<Scalar> & dx0,
				       const Vector<Scalar> & dy,
				       Vector<Scalar> & x1) const {
      RVLException e;
      e<<"ERROR: LinOpValOp::applyPartialDeriv1\n";
      e<<"  not pure virtual and no implementation supplied\n";
      throw e;
    }

    
    virtual void applyPartialDeriv20(const Vector<Scalar> & x0,
				     const Vector<Scalar> & x1,
				     const Vector<Scalar> & dx00,
				     const Vector<Scalar> & dx01,
				     Vector<Scalar> & dy) const {
      RVLException e;
      e<<"ERROR: LinOpValOp::applyPartialDeriv20\n";
      e<<"  not pure virtual and no implementation supplied\n";
      throw e;
    }
   
    
    virtual void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
					const Vector<Scalar> & x1,
					const Vector<Scalar> & dy,
					const Vector<Scalar> & dx01,
					Vector<Scalar> & dx00) const {
      RVLException e;
      e<<"ERROR: LinOpValOp::applyPartialDeriv20\n";
      e<<"  not pure virtual and no implementation supplied\n";
      throw e;
    }
    
    static void export_apply0(LinOpValOp<Scalar> const & op,
			      const Vector<Scalar> & x0,
			      const Vector<Scalar> & x1, 
			      Vector<Scalar> & y) {
      op.apply0(x0,x1,y);
    }
    
    static void export_applyAdj0(LinOpValOp<Scalar> const & op,
				 const Vector<Scalar> & x0,
				 const Vector<Scalar> & y, 
				 Vector<Scalar> & x1) {
      op.applyAdj0(x0,y,x1);
    }

    static void export_applyPartialDeriv0(LinOpValOp<Scalar> const & op,
					  const Vector<Scalar> & x0,
					  const Vector<Scalar> & x1,
					  const Vector<Scalar> & dx0,
					  Vector<Scalar> & dy) {
      op.applyPartialDeriv0(x0,x1,dx0,dy);
    }

    static void export_applyAdjPartialDeriv0(LinOpValOp<Scalar> const & op,
					     const Vector<Scalar> & x0,
					     const Vector<Scalar> & x1,
					     const Vector<Scalar> & dy,
					     Vector<Scalar> & dx0) {
      op.applyAdjPartialDeriv0(x0,x1,dy,dx0);
    }

    static void export_applyAdjPartialDeriv1(LinOpValOp<Scalar> const & op,
					     const Vector<Scalar> & x0,
					     const Vector<Scalar> & x1,
					     const Vector<Scalar> & dy,
					     Vector<Scalar> & dx0) {
      op.applyAdjPartialDeriv1(x0,dx0,dy,x1);
    }
    
    static void export_applyPartialDeriv20(LinOpValOp<Scalar> const & op,
					   const Vector<Scalar> & x0,
					   const Vector<Scalar> & x1,
					   const Vector<Scalar> & dx00,
					   const Vector<Scalar> & dx01,
					   Vector<Scalar> & dy) {
      op.applyPartialDeriv20(x0,x1,dx00,dx01,dy);
    }
    
    static void export_applyAdjPartialDeriv20(LinOpValOp<Scalar> const & op,
					      const Vector<Scalar> & x0,
					      const Vector<Scalar> & x1,
					      const Vector<Scalar> & dy,
					      const Vector<Scalar> & dx01,
					      Vector<Scalar> & dx00) {
      op.applyAdjPartialDeriv20(x0,x1,dy,dx01,dx00);
    }

    void apply(Vector<Scalar> const & x,
	       Vector<Scalar> & y) const {
      try {
	Components<Scalar> cx(x);
	apply0(cx[0],cx[1],y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinOpValOp::apply\n";
	throw e;
      }
    }
      
    void applyPartialDeriv(int i,
			   const Vector<Scalar> & x, 
			   const Vector<Scalar> & dxi,
			   Vector<Scalar> & dy) const {
      try {
	Components<Scalar> cx(x);
	if (i==0) applyPartialDeriv0(cx[0],cx[1],dxi,dy);
	else {
	  apply0(cx[0],dxi,dy);
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinOpValOp::applyPartialDeriv\n";
	throw e;
      }
    }

    void applyAdjPartialDeriv(int i,
			      const Vector<Scalar> & x, 
			      const Vector<Scalar> & dy,
			      Vector<Scalar> & dxi) const {
      try {
	Components<Scalar> cx(x);
	if (i==0) applyAdjPartialDeriv0(cx[0],cx[1],dy,dxi);
	else {
	  applyAdj0(cx[0],dy,dxi);
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinOpValOp::applyAdjPartialDeriv\n";
	throw e;
      }
    }

    // note that applyAdjPartialDeriv1 is needed only in the case
    // i=1, j=0 - which can be avoided for tomo-op like applications,
    // as the tomo op involves only i=j=0 case 
    void applyPartialDeriv2(int i,
			    int j,
			    const Vector<Scalar> & x, 
			    const Vector<Scalar> & dxi,
			    const Vector<Scalar> & dxj,
			    Vector<Scalar> & dy) const {
      try {
	Components<Scalar> cx(x);
	if (i==0) {
	  if (j==0) 
	    applyPartialDeriv20(cx[0],cx[1],dxi,dxj,dy);
	  else
	    // deriv in x0 of f(x0,dxj,y)
	    applyPartialDeriv0(cx[0],dxj,dxi,dy);
	}
	else {
	  if (j==0)
	    // deriv in x1 of D_0f(x0,x1,dxj,y)
	    applyPartialDeriv0(cx[0],dxi,dxj,dy);
	  else 
	    dy.zero();
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinOpValOp::applyAdjPartialDeriv\n";
	throw e;
      }
    }

    void applyAdjPartialDeriv2(int i,
			       int j,
			       const Vector<Scalar> & x, 
			       const Vector<Scalar> & dy,
			       const Vector<Scalar> & dxj,
			       Vector<Scalar> & dxi) const {
      try {
	Components<Scalar> cx(x);
	if (i==0) {
	  if (j==0) 
	    applyAdjPartialDeriv20(cx[0],cx[1],dy,dxj,dxi);
	  else
	    applyAdjPartialDeriv0(cx[0],dxj,dy,dxi);
	}
	else {
	  if (j==0) 
	    applyAdjPartialDeriv1(cx[0],dxj,dy,dxi);	    
	  else 
	    dxi.zero();
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinOpValOp::applyAdjPartialDeriv2\n";
	throw e;
      }      
    }
  };


  /** Given a linear operator F on x1, ConstLinOpValOp provides a
      LinOpValOp where F is considered constant wrt x0.
      Domain is assumed to be product space of two spaces, mainly 
      spaces related to nonlinear and linear parameters x0, x1 resp. 
      To construct this type of LinOpValOp only the LinearOp and a 
      space relating to x0 are required. Note that the range is 
      assumed to be naturally the range of F.
   */
  template<class Scalar>
  class ConstLinOpValOp: public LinOpValOp<Scalar> {

  private:
    
    StdProductSpace<Scalar> dom;
    LinearOp<Scalar> const &lop; //linear operator
    
  protected:

    void apply0(const Vector<Scalar> & x0,
		const Vector<Scalar> & x1, 
		Vector<Scalar> & y) const {
      lop.applyOp(x1,y);
    }
    
    /** \f$x_1 = F^*(x_0)y\f$ */
    void applyAdj0(const Vector<Scalar> & x0,
		   const Vector<Scalar> & y, 
		   Vector<Scalar> & x1) const {
      lop.applyAdjOp(y,x1);
    }

    void applyPartialDeriv0(const Vector<Scalar> & x0,
			    const Vector<Scalar> & x1,
			    const Vector<Scalar> & dx0,
			    Vector<Scalar> & dy) const {
      dy.zero();
    }

    void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
			       const Vector<Scalar> & x1,
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx0) const {
      dx0.zero();
    }
    
    void applyPartialDeriv20(const Vector<Scalar> & x0,
			     const Vector<Scalar> & x1,
			     const Vector<Scalar> & dx00,
			     const Vector<Scalar> & dx01,
			     Vector<Scalar> & dy) const {
      dy.zero();
    }
    
    void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
				const Vector<Scalar> & x1,
				const Vector<Scalar> & dy,
				const Vector<Scalar> & dx01,
				Vector<Scalar> & dx00) const {
      dx00.zero();
    }
    
    OperatorProductDomain<Scalar> * clonePD() const {
      return new ConstLinOpValOp<Scalar>(*this);
    }
    
  public:

    ConstLinOpValOp(LinearOp<Scalar> const & _lop, Space<Scalar> const & _NLsp)
      : lop(_lop), dom(_NLsp,_lop.getDomain()) {}

    ConstLinOpValOp(ConstLinOpValOp<Scalar> const & lovo)
      : lop(lovo.lop), dom(lovo.dom) {}

    ProductSpace<Scalar> const & getProductDomain() const { return dom; }
    Space<Scalar> const & getRange() const { return lop.getRange(); }

    ostream & write(ostream & str) const {
      str<<"ConstLinOpValOp of \n";
      lop.write(str);
      return str;
    }
  };


  /** standard example of LinOpValOp:
      \f$ (x,dx) \mapsto DF(x)dx\f$
  */
  template<class Scalar>
  class TangentMap: public LinOpValOp<Scalar> {

  private:

    Operator<Scalar> const & op;
    StdProductSpace<Scalar> dom;
    
  protected:

    void apply0(const Vector<Scalar> & x0,
		const Vector<Scalar> & x1, 
		Vector<Scalar> & y) const {
      try {
	RVL::Operator<Scalar>::export_applyDeriv(op,x0,x1,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from TangentMap::apply0\n";
	throw e;
      }
    }
  
    void applyAdj0(const Vector<Scalar> & x0,
		   const Vector<Scalar> & y, 
		   Vector<Scalar> & x1) const {
      try {
	RVL::Operator<Scalar>::export_applyAdjDeriv(op,x0,y,x1);
      }
      catch (RVLException & e) {
	e<<"\ncalled from TangentMap::applyAdj0\n";
	throw e;
      }
    }

    void applyPartialDeriv0(const Vector<Scalar> & x0,
			    const Vector<Scalar> & x1,
			    const Vector<Scalar> & dx0,
			    Vector<Scalar> & dy) const {
      try {
      	RVL::Operator<Scalar>::export_applyDeriv2(op,x0,x1,dx0,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from TangentMap::applyPartialDeriv0\n";
	throw e;
      }      
    }
    
    void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
			       const Vector<Scalar> & x1,
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx0) const {
      try {
	RVL::Operator<Scalar>::export_applyAdjDeriv2(op,x0,dy,x1,dx0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from TangentMap::applyPartialDeriv0\n";
	throw e;
      }
    }

    void applyPartialDeriv20(const Vector<Scalar> & x0,
				     const Vector<Scalar> & x1,
				     const Vector<Scalar> & dx00,
				     const Vector<Scalar> & dx01,
				     Vector<Scalar> & dy) const {
      RVLException e;
      e<<"ERROR: TangentMap::applyPartialDeriv20\n";
      e<<"  not defined - would involve 3rd order partial of underlying map\n";
      throw e;
    }
    
    void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
					const Vector<Scalar> & x1,
					const Vector<Scalar> & dy,
					const Vector<Scalar> & dx01,
					Vector<Scalar> & dx00) const {
      RVLException e;
      e<<"ERROR: TangentMap::applyPartialDeriv20\n";
      e<<"  not defined - would involve 3rd order partial of underlying map\n";
      throw e;
    }
    
    OperatorProductDomain<Scalar> * clonePD() const {
      return new TangentMap<Scalar>(*this);
    }
    
  public:

    TangentMap(Operator<Scalar> const & _op)
      : op(_op), dom(op.getDomain(),op.getDomain()) {}

    TangentMap(TangentMap<Scalar> const & t)
      : op(t.op), dom(t.dom) {}

    ProductSpace<Scalar> const & getProductDomain() const { return dom; }
    Space<Scalar> const & getRange() const { return op.getRange(); }

    ostream & write(ostream & str) const {
      str<<"Tangent Map of \n";
      op.write(str);
      return str;
    }
  };
    
  /** create linear op by restricting the nonlinear variable in
      LinOpValOp. Similar to RestrictOp, but differs in that only two
      factors permitted, and 0th is always the one restricted - this
      comes from the structure of LinOpValOp, where 0th is nonlinear
      component.
   */
  template<typename Scalar>
  class LinearRestrictOp: public LinearOp<Scalar> {

  private: 

    // reference OPD
    LinOpValOp<Scalar> const & ff;
    // fixed vector - in domain[0]
    Vector<Scalar> x0;
    
    LinearRestrictOp();

  protected:

    void apply(Vector<Scalar> const & x,
	       Vector<Scalar> & y) const {
      try {
	ff.apply0(x0,x,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinearRestrictOp::apply\n";
	throw e;
      }
    }

    void applyAdj(Vector<Scalar> const & y,
		  Vector<Scalar> & x) const {
      try {
	ff.applyAdj0(x0,y,x);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinearRestrictOp::applyAdj\n";
	throw e;
      }
    }
    
    Operator<Scalar> * clone() const { 
      return new LinearRestrictOp(*this);
    }
    
  public:

    /** main constructor: 
	@param _f = operaator to be restricted
	@param _x = vector in domain, 0th component to be fixed
    */
    LinearRestrictOp(LinOpValOp<Scalar> const & _f,
		     Vector<Scalar> const & _x) 
      : ff(_f), x0((_f.getProductDomain())[0]) {
      try {
	x0.copy(_x);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinearRestrictOp constructor\n";
	throw e;
      }
    }

    LinearRestrictOp(LinearRestrictOp<Scalar> const & g): ff(g.ff), x0(g.x0) {}

    ~LinearRestrictOp() {}

    Space<Scalar> const & getDomain() const { return ff.getProductDomain()[1]; }
    Space<Scalar> const & getRange() const { return ff.getRange(); }

    ostream & write(ostream & str) const {
      str<<"LinearRestrictOp with\n";
      str<<"  Vector (for 0th fixed component):\n";
      x0.write(str);
      str<<"  LinOpValOp:\n";
      ff.write(str);
      return str;
    }
  };

  /** Composition in the first component of LinOpValOp with arbitrary
      op - could be accomplished with DiagonalOp, this construction
      introduced for efficiency's sake. */
  template<class Scalar>
  class CompLOVOp: public LinOpValOp<Scalar> {

  private:

    std::shared_ptr<Operator<Scalar> > op;
    std::shared_ptr<LinOpValOp<Scalar> > lovop;
    StdProductSpace<Scalar> dom;
    
  protected:

    void apply0(const Vector<Scalar> & x0,
		const Vector<Scalar> & x1, 
		Vector<Scalar> & y) const {
      try {
	Vector<Scalar> z(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z);
	RVL::LinOpValOp<Scalar>::export_apply0(*lovop,z,x1,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::apply0\n";
	throw e;
      }
    }
  
    void applyAdj0(const Vector<Scalar> & x0,
		   const Vector<Scalar> & y, 
		   Vector<Scalar> & x1) const {
      try {
	Vector<Scalar> z(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z);
	RVL::LinOpValOp<Scalar>::export_applyAdj0(*lovop,z,y,x1);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::applyAdj0\n";
	throw e;
      }
    }

    void applyPartialDeriv0(const Vector<Scalar> & x0,
			    const Vector<Scalar> & x1,
			    const Vector<Scalar> & dx0,
			    Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z0(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z0);
	Vector<Scalar> dz(op->getRange());
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dx0,dz);
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv0(*lovop,z0,x1,dz,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::applyPartialDeriv0\n";
	throw e;
      }      
    }
    
    void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
			       const Vector<Scalar> & x1,
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx0) const {
      try {
	Vector<Scalar> z0(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z0);
	Vector<Scalar> dz(op->getRange());
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv0(*lovop,z0,x1,dy,dz);
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dz,dx0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::applyAdjPartialDeriv0\n";
	throw e;
      }
    }

    void applyPartialDeriv20(const Vector<Scalar> & x0,
			     const Vector<Scalar> & x1,
			     const Vector<Scalar> & dx00,
			     const Vector<Scalar> & dx01,
			     Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z0(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z0);
	Vector<Scalar> dz0(op->getRange());
	Vector<Scalar> dz1(op->getRange());
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dx00,dz0);
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dx01,dz1);
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv20(*lovop,z0,x1,dz0,dz1,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::applyPartialDeriv20\n";
	throw e;
      }

    }
    
    void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
				const Vector<Scalar> & x1,
				const Vector<Scalar> & dy,
				const Vector<Scalar> & dx01,
				Vector<Scalar> & dx00) const {
      try {
	Vector<Scalar> z0(op->getRange());
	RVL::Operator<Scalar>::export_apply(*op,x0,z0);
	Vector<Scalar> dz0(op->getRange());
	Vector<Scalar> dz1(op->getRange());
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dx01,dz1);
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv20(*lovop,z0,x1,dy,dz1,dz0);
	RVL::Operator<Scalar>::export_applyDeriv(*op,x0,dz0,dx00);
      }
      catch (RVLException & e) {
	e<<"\ncalled from CompLOVOp::applyAdjPartialDeriv20\n";
	throw e;
      }
    }
    
    OperatorProductDomain<Scalar> * clonePD() const {
      return new CompLOVOp<Scalar>(*this);
    }
    
  public:

    CompLOVOp(Operator<Scalar> const & _op,
	      LinOpValOp<Scalar> const & _lovop)
      : dom(_op.getDomain(),_lovop.getProductDomain()[1]) {
      op = RVL::Operator<Scalar>::clonePtr(_op);
      std::shared_ptr<RVL::Operator<Scalar> > tmp = RVL::Operator<Scalar>::clonePtr(_lovop);
      lovop = dynamic_pointer_cast<RVL::LinOpValOp<Scalar> >(tmp);
      if (!(lovop.get())) {
	RVLException e;
	e<<"ERROR: CompLOVOp constructor\n";
	e<<"  bad, bad, bad...\n";
	throw e;
      }
    }
    

    CompLOVOp(CompLOVOp<Scalar> const & t)
      : op(t.op), lovop(t.lovop), dom(t.dom) {}

    ProductSpace<Scalar> const & getProductDomain() const { return dom; }
    Space<Scalar> const & getRange() const { return lovop->getRange(); }

    ostream & write(ostream & str) const {
      str<<"Composition of Operator followed by LinOpValOp\n";
      str<<"Operator acts only on first component of LOVO domain\n";
      str<<"Operator (first factor):\n";
      op->write(str);
      str<<"LinOpValOp (second factor):\n";
      lovop->write(str);
      return str;
    }
  };

  /** Composition in the second component of LinOpValOp with arbitrary
      lop - could be accomplished with DiagonalOp, this construction
      introduced for efficiency's sake. */
  template<class Scalar>
  class LinCompLOVOp: public LinOpValOp<Scalar> {

  private:

    std::shared_ptr<LinearOp<Scalar> > lop;
    std::shared_ptr<LinOpValOp<Scalar> > lovop;
    StdProductSpace<Scalar> dom;
    
  protected:

    void apply0(const Vector<Scalar> & x0,
		const Vector<Scalar> & x1, 
		Vector<Scalar> & y) const {
      try {
	Vector<Scalar> z(lop->getRange());
	lop->applyOp(x1,z);
	RVL::LinOpValOp<Scalar>::export_apply0(*lovop,x0,z,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::apply0\n";
	throw e;
      }
    }
  
    void applyAdj0(const Vector<Scalar> & x0,
		   const Vector<Scalar> & y, 
		   Vector<Scalar> & x1) const {
      try {
	Vector<Scalar> z(lop->getRange());
	RVL::LinOpValOp<Scalar>::export_applyAdj0(*lovop,x0,y,z);
	lop->applyAdjOp(z,x1);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::applyAdj0\n";
	throw e;
      }
    }

    void applyPartialDeriv0(const Vector<Scalar> & x0,
			    const Vector<Scalar> & x1,
			    const Vector<Scalar> & dx0,
			    Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z(lop->getRange());
	lop->applyOp(x1,z);
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv0(*lovop,x0,z,dx0,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::applyPartialDeriv0\n";
	throw e;
      }      
    }
    
    void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
			       const Vector<Scalar> & x1,
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx0) const {
      try {
	Vector<Scalar> z(lop->getRange());
	lop->applyOp(x1,z);
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv0(*lovop,x0,z,dy,dx0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::applyAdjPartialDeriv0\n";
	throw e;
      }
    }

    void applyPartialDeriv20(const Vector<Scalar> & x0,
			     const Vector<Scalar> & x1,
			     const Vector<Scalar> & dx00,
			     const Vector<Scalar> & dx01,
			     Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z(lop->getRange());
	lop->applyOp(x1,z);
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv20(*lovop,x0,z,dx00,dx01,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::applyPartialDeriv20\n";
	throw e;
      }
    }
    
    void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
				const Vector<Scalar> & x1,
				const Vector<Scalar> & dy,
				const Vector<Scalar> & dx01,
				Vector<Scalar> & dx00) const {
      try {
	Vector<Scalar> z(lop->getRange());
	lop->applyOp(x1,z);
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv20(*lovop,x0,z,dy,dx01,dx00);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCompLOVOp::applyAdjPartialDeriv20\n";
	throw e;
      }
    }
    
    OperatorProductDomain<Scalar> * clonePD() const {
      return new LinCompLOVOp<Scalar>(*this);
    }
    
  public:

    LinCompLOVOp(LinearOp<Scalar> const & _lop,
		 LinOpValOp<Scalar> const & _lovop)
      : dom(_lovop.getProductDomain()[0],_lop.getDomain()) {
      
      std::shared_ptr<RVL::Operator<Scalar> > tmp_lop 
	= RVL::Operator<Scalar>::clonePtr(_lop);
      lop = dynamic_pointer_cast<RVL::LinearOp<Scalar> >(tmp_lop);
      
      std::shared_ptr<RVL::Operator<Scalar> > tmp_lovop 
	= RVL::Operator<Scalar>::clonePtr(_lovop);
      lovop = dynamic_pointer_cast<RVL::LinOpValOp<Scalar> >(tmp_lovop);
      
      if ( !(lovop.get())||!(lop.get()) ) {
	RVLException e;
	e<<"ERROR: LinCompLOVOp constructor\n";
	e<<"  bad, bad, bad...\n";
	throw e;
      }
    }
    
    LinCompLOVOp(LinCompLOVOp<Scalar> const & t)
      : lop(t.lop), lovop(t.lovop), dom(t.dom) {}

    ProductSpace<Scalar> const & getProductDomain() const { return dom; }
    Space<Scalar> const & getRange() const { return lovop->getRange(); }

    ostream & write(ostream & str) const {
      str<<"Composition of LinearOp followed by LinOpValOp\n";
      str<<"Operator acts only on second component of LOVO domain\n";
      str<<"effectively diag(LinearOp,Identity)\n";
      str<<"LinearOp:\n";
      lop->write(str);
      str<<"LinOpValOp:\n";
      lovop->write(str);
      return str;
    }
  };
    
  /** Composition on the output side of LinOpValOp with arbitrary
      lop. A CompOp construction would work, but would not guarantee
      that the result is a LOVOp, hence this class.*/
  template<class Scalar>
  class LOVCompLinOp: public LinOpValOp<Scalar> {

  private:

    std::shared_ptr<LinearOp<Scalar> > lop;
    std::shared_ptr<LinOpValOp<Scalar> > lovop;
    
  protected:

    void apply0(const Vector<Scalar> & x0,
		const Vector<Scalar> & x1, 
		Vector<Scalar> & y) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	RVL::LinOpValOp<Scalar>::export_apply0(*lovop,x0,x1,z);
	lop->applyOp(z,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::apply0\n";
	throw e;
      }
    }
  
    void applyAdj0(const Vector<Scalar> & x0,
		   const Vector<Scalar> & y, 
		   Vector<Scalar> & x1) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	lop->applyAdjOp(y,z);
	RVL::LinOpValOp<Scalar>::export_applyAdj0(*lovop,x0,z,x1);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::applyAdj0\n";
	throw e;
      }
    }

    void applyPartialDeriv0(const Vector<Scalar> & x0,
			    const Vector<Scalar> & x1,
			    const Vector<Scalar> & dx0,
			    Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv0(*lovop,x0,x1,dx0,z);
	lop->applyOp(z,dy);

      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::applyPartialDeriv0\n";
	throw e;
      }      
    }
    
    void applyAdjPartialDeriv0(const Vector<Scalar> & x0,
			       const Vector<Scalar> & x1,
			       const Vector<Scalar> & dy,
			       Vector<Scalar> & dx0) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	lop->applyAdjOp(dy,z);
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv0(*lovop,x0,x1,z,dx0);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::applyAdjPartialDeriv0\n";
	throw e;
      }
    }

    void applyPartialDeriv20(const Vector<Scalar> & x0,
			     const Vector<Scalar> & x1,
			     const Vector<Scalar> & dx00,
			     const Vector<Scalar> & dx01,
			     Vector<Scalar> & dy) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	RVL::LinOpValOp<Scalar>::export_applyPartialDeriv20(*lovop,x0,z,dx00,dx01,z);
	lop->applyOp(z,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::applyPartialDeriv20\n";
	throw e;
      }
    }
    
    void applyAdjPartialDeriv20(const Vector<Scalar> & x0,
				const Vector<Scalar> & x1,
				const Vector<Scalar> & dy,
				const Vector<Scalar> & dx01,
				Vector<Scalar> & dx00) const {
      try {
	Vector<Scalar> z(lop->getDomain());
	lop->applyAdjOp(dy,z);
	RVL::LinOpValOp<Scalar>::export_applyAdjPartialDeriv20(*lovop,x0,x1,z,dx01,dx00);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LOVCompLinOp::applyAdjPartialDeriv20\n";
	throw e;
      }
    }
    
    OperatorProductDomain<Scalar> * clonePD() const {
      return new LOVCompLinOp<Scalar>(*this);
    }
    
  public:

    LOVCompLinOp(LinOpValOp<Scalar> const & _lovop,
		 LinearOp<Scalar> const & _lop) {
      
      std::shared_ptr<RVL::Operator<Scalar> > tmp_lop 
	= RVL::Operator<Scalar>::clonePtr(_lop);
      lop = dynamic_pointer_cast<RVL::LinearOp<Scalar> >(tmp_lop);
      
      std::shared_ptr<RVL::Operator<Scalar> > tmp_lovop 
	= RVL::Operator<Scalar>::clonePtr(_lovop);
      lovop = dynamic_pointer_cast<RVL::LinOpValOp<Scalar> >(tmp_lovop);
      
      if ( !(lovop.get())||!(lop.get()) ) {
	RVLException e;
	e<<"ERROR: LOVCompLinOp constructor\n";
	e<<"  bad, bad, bad...\n";
	throw e;
      }
    }
    
    LOVCompLinOp(LOVCompLinOp<Scalar> const & t)
      : lop(t.lop), lovop(t.lovop) {}

    ProductSpace<Scalar> const & getProductDomain() const {
      return lovop->getProductDomain();
    }
    Space<Scalar> const & getRange() const { return lop->getRange(); }

    ostream & write(ostream & str) const {
      str<<"Composition of LinOpValOp followed by LinearOp\n";
      str<<"LinOpValOp:\n";
      lovop->write(str);
      str<<"LinearOp:\n";
      lop->write(str);
      return str;
    }
  };
  
  template<class Scalar>
  class InvertibleDerivEvaluation;

  /** Operators whose derivatives are supplied with inverse
      mappings. Natural grist for Newton mill.
  */

  template<class Scalar>
  class OperatorWithInvertibleDeriv : public Operator<Scalar> {
  
    friend class InvertibleDerivEvaluation<Scalar>;
    typedef typename ScalarFieldTraits<Scalar>::AbsType NormRetType;

  protected:
    
    virtual void applyInverseDeriv(const Vector<Scalar> & x,
		      const Vector<Scalar> & dy,
		      Vector<Scalar> & dx) const = 0;
    virtual void applyAdjInverseDeriv(const Vector<Scalar> & x,
				      const Vector<Scalar> & dx,
				      Vector<Scalar> & dy) const = 0;

    DerivEvaluation<Scalar> 
    * createDerivEvaluation(OperatorEvaluation<Scalar> & opeval) const;

  public:

    OperatorWithInvertibleDeriv() {}
    ~OperatorWithInvertibleDeriv() {}

    /* Performs a simple inverse check by applying the inverse, then applying
	the derivative and examining the norm of the difference.
	Returns true if test is successful, false otherwise.
  
    bool checkInverseDeriv(const Vector<Scalar> & x, 
			   const Vector<Scalar> & y,
			   NormRetType tol = 1e-4,
			   ostream & str = cout);
    */
  };

  /** OperatorEvaluation pairs a reference to a Vector with an
      independent, dynamically-allocated instance of an Operator. 

      Use of this class is extremely simple: to create the evaluation
      of an Operator f at a Vector x, use the main constructor:

      OperatorEvaluation<Scalar> fx(f,x);

      The semantics of the fx are those of f(x) for variable x. That
      is, fx and x are dynamically linked, and the results stored in
      fx change when the internal state of x changes. The mechanism by
      which this occurs is explained below. Thus after execution of,
      say,

      x.linComb(a,y) 

      (which overwrites x with x+ay), fx refers to the evaluation of f
      at the updated value of x, not at the value held by x when fx
      was created. This dynamic linkage allows a very natural
      assignment syntax for algorithm expression: create an evaluation
      (fx, say) and use it whereever f(x) would occur.

      The main role of OperatorEvaluation is to return for external
      use the values of the Operator and its derivatives. These values
      are returned by const reference to internal data owned by the
      OperatorEvaluation. The value of the Operator instance,
      evaluated at the Vector evaluation point, is the (const) return
      value of OperatorEvaluation::getValue. The derivative reference
      is returned by OperatorEvaluation::getDeriv (as a LinearOp
      instance).

      Thus submit the the value of f at x to another function g by 

      g(fx.getValue());

      (provided that the argument of g is a const Vector reference!).

      Apply the derivative of f at x to the Vector p using
      LinearOp::applyOp, storing the result in Vector q:

      fx.getDeriv().applyOp(p,q)

      The Evaluation object implements its methods by (possibly)
      altering the state of the Operator instance which it owns, the
      way in which this is done being regulated by the referenced
      Vector (evaluation point). The role of the Vector reference is
      exactly parallel to the role of the Space reference held by
      Vector, which regulates the way in which Vector changes the
      internal state of its DataContainer member

      There is a key difference: while Space is an immutable object (a
      factory), offering no public methods which alter its state,
      Vector is mutable. Therefore, in order to reduce the likelihood
      of the Evaluation object attaining an incoherent internal state,
      Vector is provided with a version index and a version increment
      method. The <i>only</i> methods altering the internal state of a
      Vector are fully implemented RVL class methods, such as the
      access methods of Evaluation types (for example
      OperatorEvaluation::getValue), the nonconst Vector::eval methods
      taking FunctionObject arguments, etc. All of these manage the
      version number. Thus the OperatorEvaluation instance can
      reliably know that its evaluation point Vector has (or has not)
      been altered by comparing its internal copy of the version index
      with that returned by Vector::getVersion. A discrepancy between
      these two copies of the version index causes the Operator * data
      member to be deleted and re-cloned, in effect forcing an update
      of all results and intermediate data.

  */

  template<class Scalar>
  class OperatorEvaluation: public Writeable {

    friend class OpComp<Scalar>;
    friend class FcnlOpComp<Scalar>;
    friend class DerivEvaluation<Scalar>;
    friend class Deriv2Evaluation<Scalar>;
    friend class PartialDerivEvaluation<Scalar>;

  private:

    const Operator<Scalar> & fref;
    WatchedVecRef<Scalar> wx;
    mutable Operator<Scalar> * f;

    mutable Vector<Scalar> val;
    mutable bool applied;
    DerivEvaluation<Scalar> * deriv;
    Deriv2Evaluation<Scalar> * deriv2;

    // disabled
    OperatorEvaluation();
  
    void reset() const {
      try {
	if (f) delete f;
	f = fref.clone();
	applied=false;
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::reset\n";
	throw e;
      }
    }

  protected:

    /** contracted version of Operator::applyDeriv: access through 
	DerivEvaluation
    */
    void applyDeriv(const Vector<Scalar> & yin,
		    Vector<Scalar> & yout) const {
      try {
	if (wx.update()) reset();
	f->applyDeriv(wx.get(),yin,yout);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::applyDeriv()\n";
	throw e;
      }
    }

    /** contracted version of Operator::applyAdjDeriv: access through 
	DerivEvaluation
    */
    void applyAdjDeriv(const Vector<Scalar> & yin,
		       Vector<Scalar> & yout) const {
      try {
	if (wx.update()) reset();
	f->applyAdjDeriv(wx.get(),yin,yout);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::applyAdjDeriv()\n";
	throw e;
      }
    }

    /** contracted version of Operator::applyDeriv2: access through 
	Deriv2Evaluation
    */
    void applyDeriv2(const Vector<Scalar> & x0,
		     const Vector<Scalar> & x1,
		     Vector<Scalar> & y) const {
      try {
	if (wx.update()) reset();
	f->applyDeriv2(wx.get(),x0,x1,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::applyDeriv2()\n";
	throw e;
      }
    }

    /** contracted version of Operator::applyAdjDeriv: access through 
	DerivEvaluation
    */
    void applyAdjDeriv2(const Vector<Scalar> & x0,
			const Vector<Scalar> & y,
			Vector<Scalar> & x1) const {
      try {
	if (wx.update()) reset();
	f->applyAdjDeriv2(wx.get(),x0,y,x1);
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::applyAdjDeriv2()\n";
	throw e;
      }
    }

    /** The next three functions throw exceptions if the 
	referenced operator is not an OpProdDom. They are 
	accessed only by PartialDerivEval, via OpProdDomEval,
	which provides compile time type-safety in addition
	to the run-time type checking built into these methods. 
    */

    const ProductSpace<Scalar> & getProductDomain() const {

      try {
	OperatorProductDomain<Scalar> * pf = NULL;
	if ((pf = dynamic_cast<OperatorProductDomain<Scalar> *>(f))) {
	  return pf->getProductDomain();
	}
	else {
	  RVLException e;
	  e<<"Error: OperatorEvaluation::getProductDomain\n";
	  e<<"referenced Operator does not have ProductSpace domain\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation::getProductDomain\n";
	throw e;
      }
    }

    // access through PartialDerivEvaluation
    void applyPartialDeriv(int i,
			   const Vector<Scalar> & yin,
			   Vector<Scalar> & yout) const {
      try {
	if (wx.update()) reset();
	OperatorProductDomain<Scalar> * pf = NULL;
	if ((pf = dynamic_cast<OperatorProductDomain<Scalar> *>(f))) {
	  pf->applyPartialDeriv(i,wx.get(),yin,yout);
	}
	else {
	  RVLException e;
	  e<<"Error: OperatorEvaluation::applyPartialDeriv\n";
	  e<<"referenced Operator does not have ProductSpace domain\n";
	  e<<"so partial derivatives are not defined\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation";
	e<<"::applyPartialDeriv()\n";
	throw e;
      }
    }

    // access through PartialDerivEvaluation
    void applyAdjPartialDeriv(int i,
			      const Vector<Scalar> & yin,
			      Vector<Scalar> & yout) const {
      try {
	if (wx.update()) reset();
	OperatorProductDomain<Scalar> * pf = NULL;
	if ((pf = dynamic_cast<OperatorProductDomain<Scalar> *>(f))) {
	  pf->applyAdjPartialDeriv(i,wx.get(),yin,yout);
	}
	else {
	  RVLException e;
	  e<<"Error: OperatorEvaluation::applyAdjPartialDeriv\n";
	  e<<"referenced Operator does not have ProductSpace domain\n";
	  e<<"so partial derivatives are not defined\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation";
	e<<"::applyAdjPartialDeriv()\n";
	throw e;
      }
    }

    /* void applyInverseDeriv( const Vector<Scalar> & dyin,
			    Vector<Scalar> & dxout) const {
      try {
	if (wx.update()) reset();
	OperatorWithInvertibleDeriv<Scalar> * pf = NULL;
	if (pf = dynamic_cast<OperatorWithInvertibleDeriv<Scalar> *>(f)) {
	  pf->applyInverseDeriv(wx.get(),dyin,dxout);
	}
	else {
	  RVLException e;
	  e<<"Error: OperatorEvaluation::applyInverseDeriv\n";
	  e<<"referenced Operator does not have an invertible derivative\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation";
	e<<"::applyInverseDeriv()\n";
	throw e;
      }
    }
    
    void applyAdjInverseDeriv( const Vector<Scalar> & dxin,
			    Vector<Scalar> & dyout) const {
      try {
	if (wx.update()) reset();
	OperatorWithInvertibleDeriv<Scalar> * pf = NULL;
	if (pf = dynamic_cast<OperatorWithInvertibleDeriv<Scalar> *>(f)) {
	  pf->applyAdjInverseDeriv(wx.get(),dxin,dyout);
	}
	else {
	  RVLException e;
	  e<<"Error: OperatorEvaluation::applyAdjInverseDeriv\n";
	  e<<"referenced Operator does not have an invertible derivative\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorEvaluation";
	e<<"::applyAdjInverseDeriv()\n";
	throw e;
      }
    }
    */

    /** operator new - not available to general public, but
	available to children and friends 

	Version 1.0: user control
    */

#ifndef RVL_OPERATOR_NEW_ENABLED
    void * operator new(size_t size) { 
      void * ptr;
      ptr = (void *) ::new unsigned char[size]; 
      return ptr;
    }
#endif

  public:

    OperatorEvaluation(const Operator<Scalar> & _f, 
		       const Vector<Scalar> & x)
      : fref(_f), wx(x), 
	val(fref.getRange()), applied(false), 
	deriv(_f.createDerivEvaluation(*this)),
	deriv2(_f.createDeriv2Evaluation(*this)) { 
      f = fref.clone(); 

      if (x.getSpace() != fref.getDomain()) {
	RVLException e;
	e<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
	e<<"Error: OperatorEvaluation constructor\n";
	e<<"-- evaluation point not in domain of operator\n";
	e<<"**********************\n";
	e<<"***    operator:   ***\n";
	e<<"**********************\n";
	fref.write(e);
	e<<"**********************\n";
	e<<"*** domain space:  ***\n";
	e<<"**********************\n";
	fref.getDomain().write(e);
	e<<"**********************\n";
	e<<"*** input space:   ***\n";
	e<<"**********************\n";
	x.getSpace().write(e);
	e<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n";
	throw e;
      }
      
    }

    OperatorEvaluation(const OperatorEvaluation<Scalar> & ev)
      : wx(ev.wx), f(ev.fref.clone()), fref(ev.fref),
	val(fref.getRange()), applied(false), 
	deriv(f->createDerivEvaluation(*this)),
	deriv2(f->createDeriv2Evaluation(*this)) { }

    virtual ~OperatorEvaluation() {
      if( deriv) {
	delete deriv;
	deriv = NULL;
      }
      if( deriv2) {
	delete deriv2;
	deriv2 = NULL;
      }
      if (f) delete f; 
    }

    /** access to domain, implemented by delegation to Operator reference
	data member
    */
    Space<Scalar> const & getDomain() const { return fref.getDomain(); }

    /** access to range, implemented by delegation to Operator reference
	data member
    */
    Space<Scalar> const & getRange() const { return fref.getRange(); }

    /** reference to evaluation point - can be assigned to */
    Vector<Scalar> & getPoint() { return wx.get(); }
    Vector<Scalar> const & getPoint() const { return wx.get(); }

    /** reference to evaluated operator copy - cannot be assigned.
	Supplied to enable access to special attributes of child
	operator classes, in the instance currently in use by the
	Evaluation object. Will require dynamic casting to acquire
	correct interface to access these additional attributes, which
	must themselves be const.
    */

    Operator<Scalar> const & getOp() const { return *f; }

    /** const reference to value (internal datum). 
    */
    Vector<Scalar> const & getValue() const {
      try {
	if (wx.update()) reset();	
	if (!applied) {
	  f->apply(wx.get(),val);
	  applied=true;
	}
	return val;
      }
      catch (RVLException & e) {
	e<<"\ncalled in OperatorEvaluation::getValue\n";
	throw e;
      }
    }

    /** const reference to derivative (internal datum) */
    LinearOp<Scalar> const & getDeriv() const { return *deriv; }
    /** const reference to 2nd derivative (internal datum) */
    SymmetricBilinearOp<Scalar> const & getDeriv2() const { return *deriv2; }

    ostream & write(ostream & str) const{
      str<<"Operator Evaluation:"<<"\n";
      str<<"  Operator:\n";
      fref.write(str);
      str<<"  evaluated at Vector:\n";
      wx.get().write(str);
      return str;
    }
  };

  /** Implements the derivative by delegating the implementation of
      the apply methods to the Operator class, by way of the
      Evaluation.  As no access to internal state (consisting only of
      an Evaluation reference) is provided, instances are effectively
      immutable. Only manufactured by OperatorEvaluation class - the
      nontrivial constructor is protected (others are private and not
      implemented) and OperatorEvaluation is the only friend class.
  */
  template<class Scalar>
  class DerivEvaluation: public LinearOp<Scalar> {

    friend class OperatorEvaluation<Scalar>;
    friend class Operator<Scalar>;

  private:

    // disabled
    DerivEvaluation();

  protected:

    OperatorEvaluation<Scalar> & fx;

    DerivEvaluation(const DerivEvaluation<Scalar> & d)
      : fx(d.fx) {}

    /** Records reference to Evaluation object */
    DerivEvaluation(OperatorEvaluation<Scalar> & _fx): fx(_fx) {}

    LinearOp<Scalar> * clone() const {
      return new DerivEvaluation<Scalar>(*this);
    }

    /** supplied to enable child classes to access Operator
	data member directly */
    Operator<Scalar> & getOp() const { return fx.getOp(); }

    /** image, application, MatVec product, whatever, via
	protected method of Evaluation datum */
    void apply(const Vector<Scalar> & y, 
	       Vector<Scalar> & z) const {
      try {
	fx.applyDeriv(y,z);
      }
      catch (RVLException & e) {
	e<<"\ncalled in DerivEvaluation::applyOp\n";
	throw e;
      }
    }

    /** image of adjoint operator, via
	protected method of Evaluation datum */
    void applyAdj(const Vector<Scalar> & y,
		  Vector<Scalar> & z) const {
      try {
	fx.applyAdjDeriv(y,z);
      }
      catch (RVLException & e) {
	e<<"\ncalled in DerivEvaluation::applyAdjOp\n";
	throw e;
      }
    }

  public:

    ~DerivEvaluation() {}

    /** access to domain, delegated to Evaluation datum */
    const Space<Scalar> & getDomain() const { return fx.getDomain(); }
    /** access to range, delegated to Evaluation datum */
    const Space<Scalar> & getRange() const { return fx.getRange(); }

    ostream & write(ostream & str) const{
      str<<"Derivative operator"<<"\n";
      str<<"part of operator evaluation"<<"\n";
      fx.write(str);
      return str;
    }
  };

  /** Implements the 2nd derivative by delegating the implementation of
      the apply methods to the Operator class, by way of the
      Evaluation.  As no access to internal state (consisting only of
      an Evaluation reference) is provided, instances are effectively
      immutable. Only manufactured by OperatorEvaluation class - the
      nontrivial constructor is protected (others are private and not
      implemented) and OperatorEvaluation is the only friend class.
  */
  template<class Scalar>
  class Deriv2Evaluation: public SymmetricBilinearOp<Scalar> {

    friend class OperatorEvaluation<Scalar>;
    friend class Operator<Scalar>;

  private:

    // disabled
    Deriv2Evaluation();

  protected:

    OperatorEvaluation<Scalar> & fx;

    Deriv2Evaluation(const Deriv2Evaluation<Scalar> & d)
      : fx(d.fx) {}

    /** Records reference to Evaluation object */
    Deriv2Evaluation(OperatorEvaluation<Scalar> & _fx): fx(_fx) {}

    SymmetricBilinearOp<Scalar> * clone() const {
      return new Deriv2Evaluation<Scalar>(*this);
    }

    /** supplied to enable child classes to access Operator
	data member directly */
    Operator<Scalar> & getOp() const { return fx.getOp(); }

    /** image, application, MatVec product, whatever, via
	protected method of Evaluation datum */
    void apply(const Vector<Scalar> & y0, 
	       const Vector<Scalar> & y1, 
	       Vector<Scalar> & z) const {
      try {
	fx.applyDeriv2(y0,y1,z);
      }
      catch (RVLException & e) {
	e<<"\ncalled in Deriv2Evaluation::applyOp\n";
	throw e;
      }
    }

    /** image of adjoint operator, via
	protected method of Evaluation datum */
    void applyAdj(const Vector<Scalar> & y0,
		  const Vector<Scalar> & z,
		  Vector<Scalar> & y1) const {
      try {
	fx.applyAdjDeriv2(y0,z,y1);
      }
      catch (RVLException & e) {
	e<<"\ncalled in Deriv2Evaluation::applyAdjOp\n";
	throw e;
      }
    }

  public:

    ~Deriv2Evaluation() {}

    /** access to domain, delegated to Evaluation datum */
    const Space<Scalar> & getDomain() const { return fx.getDomain(); }
    /** access to range, delegated to Evaluation datum */
    const Space<Scalar> & getRange() const { return fx.getRange(); }

    ostream & write(ostream & str) const{
      str<<"Second Derivative operator"<<"\n";
      str<<"part of operator evaluation"<<"\n";
      fx.write(str);
      return str;
    }
  };

  /** Evaluation of derivative supplied with inverse mappings. */

  template<class Scalar>
  class InvertibleDerivEvaluation 
    : public DerivEvaluation<Scalar>, public Invertible<Scalar> {
 
    friend class OperatorWithInvertibleDeriv<Scalar>;

  protected:

    LinearOp<Scalar> * clone() const {
      return new InvertibleDerivEvaluation<Scalar>(*this);
    }

    InvertibleDerivEvaluation(const InvertibleDerivEvaluation<Scalar> & s)
      :DerivEvaluation<Scalar>(s) {}

    /** This function assigns to y the value \f$ A^{-1} * x\f$, and
	is the same as solving the system \f$ A * y = x \f$ for y.
    */
    void applyInv(const Vector<Scalar> & x, 
		  Vector<Scalar> & y) const {
      try {
	OperatorWithInvertibleDeriv<Scalar> & opwid = 
	  dynamic_cast<OperatorWithInvertibleDeriv<Scalar> &>(this->getOp());
	opwid.applyInverseDeriv(this->fx.getPoint(), x, y);
      }
      catch (bad_cast) {
	RVLException e;
	e<<"Error: InvertibleDerivEvaluation::applyInv\n";
	e<<"operator does not have invertible deriv\n";
	throw e;
      }
    }

    /** This function assigns to y the value \f$ A^{-T} * x\f$, and
	is the same as solving the system \f$ A^{T} * y = x \f$ for y.
    */
    void applyInvAdj(const Vector<Scalar> & x, 
		     Vector<Scalar> & y) const {
      try {
	OperatorWithInvertibleDeriv<Scalar> & opwid = 
	  dynamic_cast<OperatorWithInvertibleDeriv<Scalar> &>(this->getOp());
	opwid.applyAdjInverseDeriv(this->fx.getPoint(), x, y);
      }
      catch (bad_cast) {
	RVLException e;
	e<<"Error: InvertibleDerivEvaluation::applyInvAdj\n";
	e<<"operator does not have invertible deriv\n";
	throw e;
      }
    }

  public:

    InvertibleDerivEvaluation(OperatorEvaluation<Scalar> & _fx) 
      : DerivEvaluation<Scalar>(_fx) {}

    /** access to domain, delegated to Evaluation datum */
    const Space<Scalar> & getDomain() const { return this->fx.getDomain(); }
    /** access to range, delegated to Evaluation datum */
    const Space<Scalar> & getRange() const { return this->fx.getRange(); }

    ostream & write(ostream & str) const{
      str<<"Invertible Derivative operator"<<"\n";
      str<<"part of operator evaluation"<<"\n";
      this->fx.write(str);
      return str;
    }

  };

  /** Evaluation for product domain case, provided only for type-safety */
  template<class Scalar>
  class OperatorProductDomainEvaluation: public OperatorEvaluation<Scalar> {

    friend class PartialDerivEvaluation<Scalar>;  // added by Yin at 07.15.2013

    PartialDerivEvaluation<Scalar> deriv;

    // disabled
    OperatorProductDomainEvaluation();
    OperatorProductDomainEvaluation
    (const OperatorProductDomainEvaluation<Scalar> &);
  
  public:
  
    /** Main constructor: takes an OperatorProductDomain and
	a Vector, records these. */
    OperatorProductDomainEvaluation(OperatorProductDomain<Scalar> & _f, 
				    const Vector<Scalar> & _x)
      : OperatorEvaluation<Scalar>(_f,_x), deriv(*this) {}

    virtual ~OperatorProductDomainEvaluation() {}

    /** returnse reference to partial derivative operators by index
	(internal datum)*/
    const LinearOp<Scalar> & getPartialDeriv(int ic) { 
      try {
	deriv.setBlock(ic);
	return deriv;
      }
      catch (RVLException & e) {
	e<<"\ncalled from OperatorProductDomainEvaluation::getPartialDeriv\n";
	throw e;
      }
    }

    ostream & write(ostream & str) const{
      str<<"Operator Evaluation with Product Domain; as"<<"\n";
      return OperatorEvaluation<Scalar>::write(str);
    }
  };

  /** similar in structure to DerivEvaluation */

  template<class Scalar>
  class PartialDerivEvaluation: public LinearOp<Scalar> {

    friend class OperatorProductDomainEvaluation<Scalar>; 

  private:

    OperatorProductDomainEvaluation<Scalar> & fx;
    int ic;

    // disabled
    PartialDerivEvaluation();
    PartialDerivEvaluation(const PartialDerivEvaluation<Scalar> & d)
      : fx(d.fx), ic(d.ic) {}

  protected:

    PartialDerivEvaluation(OperatorProductDomainEvaluation<Scalar> & _fx)
      : fx(_fx), ic(0) {}

   LinearOp<Scalar> * clone() const { 
      return new PartialDerivEvaluation<Scalar>(*this);
    }

    // image, application, MatVec product, whatever
    void apply(const Vector<Scalar> & y, 
	       Vector<Scalar> & z) const {
      try { fx.applyPartialDeriv(ic,y,z); }
      catch (RVLException & e) {
	e<<"\ncalled in PartialDerivEvaluation::apply\n";
	throw e;
      }
    }

    // image of adjoint (transpose) operator
    void applyAdj(const Vector<Scalar> & y,
		  Vector<Scalar> & z) const {
      try { fx.applyAdjPartialDeriv(ic,y,z); }
      catch (RVLException & e) {
	e<<"\ncalled in PartialDerivEvaluation::applyAdj\n";
	throw e;
      }
    }

  public:

    ~PartialDerivEvaluation() {}

    const Space<Scalar> & getDomain() const { 
      try { return (fx.getProductDomain())[ic]; }
      catch (RVLException & e) {
	e<<"\ncalled from PartialDerivEvaluation::getProductDomain()\n";
	throw e;
      }
    }

    const Space<Scalar> & getRange() const { return fx.getRange(); }

    void setBlock(int i) { ic=i; }  // added by Yin at 07.15.2013

    ostream & write(ostream & str) const{
      str<<"Partial Derivative operator"<<"\n";
      str<<"component "<<ic<<"\n";
      str<<"part of functional evaluation"<<"\n";
      fx.write(str);
      return str;
    }
  };

  /** LNLOperator creates a nonlinear op from a linear operator.
      That is, it returns a nonlinear operator object (i.e. an instance of
      Operator) which has precisely the same mapping behaviour as
      a linear operator (i.e. an instance of LinearOp). This is
      useful for instance in creating formally nonlinear least squares
      functions using LeastSquaresFcnlGN (which can be fed to
      various nonlinear optimization algorithms),which are actually
      linear least squares functions. */ 

  template<class Scalar>
  class LNLOperator: public Operator<Scalar> {
  private:

    LinearOp<Scalar> const & L;
    // disabled
    LNLOperator();

  protected:

    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & y) const {
      try {
	L.applyOp(x,y);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LNLOperator::apply\n";
	throw e;
      }
    }
  
    void applyDeriv(const Vector<Scalar> & x, 
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & dy) const {
      try {
	L.applyOp(dx,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LNLOperator::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(const Vector<Scalar> & x, 
		       const Vector<Scalar> & dy,
		       Vector<Scalar> & dx) const {
      try {
	L.applyAdjOp(dy,dx);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LNLOperator::applyAdjDeriv\n";
	throw e;
      }
    }
  
  public:

    /// Usual constructor; just needs a pointer to the linear operator.
    LNLOperator(LinearOp<Scalar> const & LL) : L(LL) {}
    LNLOperator(const LNLOperator<Scalar> & op) : L(op.L) {}
    ~LNLOperator() {}
    
    // virtual copy constructor - permits override
    virtual Operator<Scalar> * clone() const {
      return new LNLOperator<Scalar>(*this);
    }

    /** access to domain, range */
    const Space<Scalar> & getDomain() const { return L.getDomain(); }
    const Space<Scalar> & getRange() const { return L.getRange(); }

    ostream & write(ostream & str) const {
      str<<"Linear operator as operator"<<"\n";
      L.write(str);
      return str;
    }
  };

  /** ANLOperator creates a nonlinear op from an affine operator.
      That is, it returns a nonlinear operator object (i.e. an
      instance of Operator) which has precisely the same mapping
      behaviour as a linear operator (i.e. an instance of LinearOp),
      plus a shift. This is useful for instance in creating formally
      nonlinear least squares functions using LeastSquaresFcnlGN
      (which can be fed to various nonlinear optimization
      algorithms), which are actually linear least squares
      functions. */ 

  template<class Scalar>
  class ANLOperator: public Operator<Scalar> {
  private:

    LinearOp<Scalar> const & L;
    Vector<Scalar> const & d;
    // disabled
    ANLOperator();

  protected:

    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & y) const {
      try {
	L.applyOp(x,y);
	y.linComb(-1.0,d);
      }
      catch (RVLException & e) {
	e<<"\ncalled from ANLOperator::apply\n";
	throw e;
      }
    }
  
    void applyDeriv(const Vector<Scalar> & x, 
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & dy) const {
      try {
	L.applyOp(dx,dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from ANLOperator::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(const Vector<Scalar> & x, 
		       const Vector<Scalar> & dy,
		       Vector<Scalar> & dx) const {
      try {
	L.applyAdjOp(dy,dx);
      }
      catch (RVLException & e) {
	e<<"\ncalled from ANLOperator::applyAdjDeriv\n";
	throw e;
      }
    }
  
  public:

    /// Usual constructor; just needs a pointer to the linear operator.
    ANLOperator(LinearOp<Scalar> const & LL, Vector<Scalar> const & dd) 
      : L(LL), d(dd) {}
    ANLOperator(const ANLOperator<Scalar> & op) : L(op.L), d(op.d) {}
    ~ANLOperator() {}

    // virtual to permit override
    virtual Operator<Scalar> * clone() const {
      return new ANLOperator<Scalar>(*this);
    }

    /** access to domain, range */
    Space<Scalar> & getDomain() const { return L.getDomain(); }
    Space<Scalar> & getRange() const { return L.getRange(); }

    ostream & write(ostream & str) const {
      str<<"Affine operator as operator: linear op"<<"\n";
      L.write(str);
      str<<"*** shift vector\n";
      d.write(str);
      return str;
    }
  };

  /** Standard construction of an op, given spaces for domain and
      range and several FunctionObject instances implementing the various
      apply operations: in the notation of the main constructor
      OpFO::OpFO, the first FunctionObject argument (f) is used to
      implement OpFO::apply, the second (dff) to implement
      OpFO::applyDeriv, and the third (dfa) to implement
      OpFO::applyAdjDeriv.

      Major Change 29.04.10: added alternate form of constructor to transfer
      RVL::Vector parameters to internal data. Permits use of FOs depending on 
      additional data encapsulated in RVL::Vectors, apart from domain and range.
      Non-Vector parameters should be written into the FO classes.

      Not intended for subclassing - key functions are not virtual.
  */

  template<class Scalar>
  class OpFO: public Operator<Scalar> {
  private:
    
    FunctionObject & f;
    FunctionObject & dff;
    FunctionObject & dfa;
    
    Space<Scalar> const & dom;
    Space<Scalar> const & rng;
    
    mutable std::vector< RVL::Vector<Scalar> const *> inp;
    mutable std::vector< RVL::Vector<Scalar> const *> inpd;

    OpFO();
    
  protected:
    
    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & y) const {
      try {
	inp[0]=&x;
	y.eval(f,inp);
      }
      catch (RVLException & e) {
	e<<"\ncalled in OpFO::apply\n";
	throw e;
      }
    }

    void applyDeriv(const Vector<Scalar> & x, 
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & z) const {
      try {
	inpd[0]=&x;
	inpd[1]=&dx;
	z.eval(dff,inpd);
      }
      catch (RVLException & e) {
	e<<"\ncalled in OpFO::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(const Vector<Scalar> & x, 
		       const Vector<Scalar> & y,
		       Vector<Scalar> & z) const {
      try {
	inpd[0]=&x;
	inpd[1]=&y;
	z.eval(dfa,inpd);
      }
      catch (RVLException & e) {
	e<<"\ncalled in OpFO::applyAdjDeriv\n";
	throw e;
      }
    }


  public:

    OpFO(const OpFO<Scalar> & A): 
      dom(A.dom), rng(A.rng),
      f(A.f), dff(A.dff), dfa(A.dfa),
      inp(A.inp), inpd(A.inpd) {}

    OpFO(Space<Scalar> const & _dom,
	 Space<Scalar> const & _rng,
	 FunctionObject & _f,
	 FunctionObject & _dff,
	 FunctionObject & _dfa):
      dom(_dom), rng(_rng), f(_f), dff(_dff), dfa(_dfa),
      inp(1), inpd(2) {}

    OpFO(Space<Scalar> const & _dom,
	 Space<Scalar> const & _rng,
	 FunctionObject & _f,
	 FunctionObject & _dff,
	 FunctionObject & _dfa,
	 std::vector<RVL::Vector<Scalar> const *> par):
      dom(_dom), rng(_rng), f(_f), dff(_dff), dfa(_dfa), 
      inp(1+par.size()), inpd(2+par.size()) {
      for (int i=0;i<par.size();i++) { inp[i+1]=par[i]; inpd[i+2]=par[i]; }
    }

    ~OpFO() {}

    // this class is considered terminal, with no overrides foreseen,
    // so clone method is not virtual
    Operator<Scalar> * clone() const { return new OpFO<Scalar>(*this); }

    // access to domain, range
    const Space<Scalar> & getDomain() const { return dom; }
    const Space<Scalar> & getRange() const { return rng; }

    ostream & write(ostream & str) const {
      str<<"Operator built of function object components"<<endl;
      str<<"image function:"<<endl;
      f.write(str);
      str<<"derivative image function:"<<endl;
      dff.write(str);
      str<<"derivative adjoint image function:"<<endl;
      dfa.write(str);
      return str;
    }

  };

  /** LinCombOperator is a concrete class implementing a linear
      combination of two or more Operator instances.

      To construct the Operator \f$M = 2.0*L_1-3.7*L_2+9.0*L_3\f$, where
      L1, L2 and L3 are Operator instances,

      LinCombOperator<float> M(2.0,L1,-3.7,L2,9.0,L3);

      Constructors are provided for 2, 3, 4, and 5 summands; larger
      linear combinations may be built by recursively combining these.

      Note that the LinCombOperator constructor is stack-based, that
      is, the linear combination must be instantiated within the scope
      of its summands. As with other fundamental RVL classes, this
      restriction exists to make dangling reference busts
      impossible. This restriction is necessary, absent enforced
      employment of smart pointers, since operator subtypes may store
      references to instances of other, stack-allocated data types.

      The range and domain are determined by the operator in the first
      summand. All subsequent summands are checked for matching domain
      and range as they are submitted.
  */

  template<class Scalar>
  class LinCombOperator: public Operator<Scalar> {
  private:
  
    mutable std::vector<Operator<Scalar> *> opvec;
    mutable std::vector<Scalar> wtvec;
    mutable bool applied;

    /** Run-time initialization */
    void setNext(Scalar a, Operator<Scalar> const & op) {
      try {
	if (applied) {
	  RVLException e;
	  e<<"Error: LinCombOperator::setNext\n";
	  e<<"object already initialized - non-initialization method called\n";
	  e<<"further alteration to object data not allowed\n";
	  throw e;
	}
	if (opvec.size() > 0) {
	  if ( (op.getDomain() != opvec[0]->getDomain()) ||
	       (op.getRange()  != opvec[0]->getRange()) ) {
	    RVLException e;
	    e<<"Error: LinCombOp::setNext\n";
	    e<<"domain or ranges of input operator incompatible with reference (summand 0)\n";
	    e<<"*** input operator:\n";
	    op.write(e);
	    e<<"*** reference operator:\n";
	    opvec[0]->write(e);
	    throw e;
	  }
	}
	wtvec.push_back(a);
	opvec.push_back(RVL::Operator<Scalar>::export_clone(op));
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::setNext\n";
      }
    }

  protected:

    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & val) const {
      try {
   
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: LinCombOp::apply\n";
	  e<<"not initialized\n";
	  throw e;
	}
	applied = true;
	this->export_apply(*(opvec[0]),x,val);
	val.scale(wtvec[0]);
	if (opvec.size() > 1) {
	  Vector<Scalar> tmp(opvec[0]->getRange());
	  for (int i=i; i<(int)opvec.size(); i++) {
	    this->export_apply(*(opvec[i]),x,tmp);
	    val.linComb(wtvec[i],tmp);
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::apply\n";
	throw e;
      }
    }

    void applyDeriv(const Vector<Scalar> & x,
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & dy) const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: LinCombOp::applyDeriv\n";
	  e<<"not initialized\n";
	  throw e;
	}
	applied = true;
	this->export_applyDeriv(*(opvec[0]),x,dx,dy);
	dy.scale(wtvec[0]);
	if (opvec.size() > 1) {
	  Vector<Scalar> tmp(opvec[0]->getRange());
	  for (int i=i; i<(int)opvec.size(); i++) {
	    this->export_applyDeriv(*(opvec[i]),x,dx,tmp);
	    dy.linComb(wtvec[i],tmp);
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(const Vector<Scalar> & x,
		       const Vector<Scalar> & dy,
		       Vector<Scalar> & dx) const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: LinCombOp::applyAdjDeriv\n";
	  e<<"not initialized\n";
	  throw e;
	}
	applied = true;
	this->export_applyAdjDeriv(*(opvec[0]),x,dy,dx);
	dx.scale(wtvec[0]);
	if (opvec.size() > 1) {
	  Vector<Scalar> tmp(opvec[0]->getDomain());
	  for (int i=i; i<(int)opvec.size(); i++) {
	    this->export_applyAdjDeriv(*(opvec[i]),x,dy,tmp);
	    dx.linComb(wtvec[i],tmp);
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::applyAdjDeriv\n";
	throw e;
      }
    }

    Operator<Scalar> * clone() const { 
      applied = true;
      return new LinCombOperator<Scalar>(*this); 
    }

  public:
  
    LinCombOperator(LinCombOperator<Scalar> const & op) {
      try {
	for (int i=0;i<op.opvec.size(); i++) {
	  opvec.push_back(op.opvec[i]->clone());
	  wtvec.push_back(op.wtvec[i]);
	}	
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator copy constructor\n";
      }
    }

    LinCombOperator(Scalar a1, Operator<Scalar> const & op1,
		    Scalar a2, Operator<Scalar> const & op2)
      : opvec(2), wtvec(2) {
      try {
	this->setNext(a1, op1);
	this->setNext(a2, op2);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator pair constructor\n";
	throw e;
      }
    }

    LinCombOperator(Scalar a1, Operator<Scalar> const & op1,
		    Scalar a2, Operator<Scalar> const & op2,
		    Scalar a3, Operator<Scalar> const & op3)
      : opvec(3), wtvec(3) {
      try {
	this->setNext(a1, op1);
	this->setNext(a2, op2);
	this->setNext(a3, op3);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator triple constructor\n";
	throw e;
      }
    }

    LinCombOperator(Scalar a1, Operator<Scalar> const & op1,
		    Scalar a2, Operator<Scalar> const & op2,
		    Scalar a3, Operator<Scalar> const & op3,
		    Scalar a4, Operator<Scalar> const & op4)
      : opvec(4), wtvec(4) {
      try {
	this->setNext(a1, op1);
	this->setNext(a2, op2);
	this->setNext(a3, op3);
	this->setNext(a4, op4);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator quad constructor\n";
	throw e;
      }
    }

    LinCombOperator(Scalar a1, Operator<Scalar> const & op1,
		    Scalar a2, Operator<Scalar> const & op2,
		    Scalar a3, Operator<Scalar> const & op3,
		    Scalar a4, Operator<Scalar> const & op4,
		    Scalar a5, Operator<Scalar> const & op5)
      : opvec(2), wtvec(2) {
      try {
	this->setNext(a1, op1);
	this->setNext(a2, op2);
	this->setNext(a3, op3);
	this->setNext(a4, op4);
	this->setNext(a5, op5);
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator quint constructor\n";
	throw e;
      }
    }

    ~LinCombOperator() {
	for (int i=0;i<(int)opvec.size(); i++) if (opvec[i]) delete opvec[i];
    }

    /** access to domain and range */
    const Space<Scalar> & getDomain() const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: LinCombOperator::getDomain\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	applied = true;
	return opvec[0]->getDomain();
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::getDomain\n";
      }
    }

    const Space<Scalar> & getRange() const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: LinCombOperator::getDomain\n";
	  e<<"object not initialized\n";
	  throw e;
	} 
	applied = true;
	return opvec[0]->getRange(); 
      }
      catch (RVLException & e) {
	e<<"\ncalled from LinCombOperator::getRange\n";
      }
    }

    ostream & write(ostream & str) const {
      str<<"LinCombOperator: linear combination of vector-valued functions\n";
      if (opvec.size()<1) {
	str<<"not initialized\n";
      }
      else {
	  for (int i=0;i<(int)opvec.size();i++) {
	  str<<" --- Operator "<<i<<" with weight "<<wtvec[i]<<"\n";
	  opvec[i]->write(str);
	}
      }
      return str;
    }
  };

  /** Convenience class used in formulation of linear combination,
      composition algorithms to avoid unnecessary temporary storage
      and computation, which would result from using
      OperatorEvaluation in the same settings. */

  template<typename Scalar>
  class LinearOpEvaluation {
    
  private:

    Vector<Scalar> const & ref;
    LinearOp<Scalar> const & op;
    mutable Vector<Scalar> val;
    mutable bool applied;

    LinearOpEvaluation();
    LinearOpEvaluation(LinearOpEvaluation<Scalar> const &);

  public:

    LinearOpEvaluation(LinearOp<Scalar> const & _op,
		       Vector<Scalar> const & _ref)
     : ref(_ref), op(_op), val(op.getRange()), applied(false) {
      if (ref.getSpace() != op.getDomain()) {
	RVLException e;
	e<<"Error: LinearOpEvaluation constructor\n";
	e<<"input vector not in domain of operator\n";
	e<<"\nvector:\n";
	ref.write(e);
	e<<"\noperator:\n";
	op.write(e);
	throw e;
      }
    }

    Vector<Scalar> const & getValue() const {
      if (!applied) {
	op.applyOp(ref,val);
	applied=true;
      }
      return val;
    }
  
  };
  
  /** Another convenience handle class used in formulation of linear
      combination, composition algorithms to avoid unnecessary
      temporary storage and computation, which would result from using
      OperatorEvaluation in the same settings. */

  template<typename Scalar>
  class LinearOpAdjEvaluation {
    
  private:

    Vector<Scalar> const & ref;
    LinearOp<Scalar> const & op;
    mutable Vector<Scalar> val;
    mutable bool applied;

    LinearOpAdjEvaluation();
    LinearOpAdjEvaluation(LinearOpEvaluation<Scalar> const &);

  public:

    LinearOpAdjEvaluation(LinearOp<Scalar> const & _op,
			  Vector<Scalar> const & _ref)
      : ref(_ref), op(_op), val(op.getDomain()), applied(false) {
      if (ref.getSpace() != op.getRange()) {
	RVLException e;
	e<<"Error: LinearOpAdjEvaluation constructor\n";
	e<<"input vector not in range of operator\n";
	e<<"\nvector:\n";
	ref.write(e);
	e<<"\noperator:\n";
	op.write(e);
	throw e;
      }
    }

    Vector<Scalar> const & getValue() const {
      if (!applied) {
	op.applyAdjOp(ref,val);
	applied=true;
      }
      return val;
    }
  
  };
  
  /** OpComp is a concrete class implementing composition
      of any number of Operator and/or LinearOp instancess.

      To construct an Operator representation of the composition \f$x
      \mapsto M(x)=L2(L1(x))\f$ (template types left out for
      brevity):

      OpComp M(L1,L2);

      Note the order: the Operator (or LinearOp) to be evaluated first
      is the first constructor argument, the operator to be evaluated
      second is the second argument.

      Compositions of more than two operators can be built up by
      recursion, using the two-operator composition constructor
      above. Alternatively, convenience constructors are supplied for
      up to five-fold composition: for example,

      OpComp M(L1,L2,L3,L4,L5)

      produces \f$x \mapsto M(x)=L5(L4(L3(L2(L1(x)))))\f$.

      Note that the OpComp constructor is stack-based, that is, the
      composition must be instantiated within the scope of its
      factors. As with other fundamental RVL classes, this restriction
      exists to make dangling reference busts impossible. This
      restriction is necessary, absent enforced employment of smart
      pointers, since operator subtypes may store references to
      instances of other, stack-allocated data types.

      The derivative and adjoint derivative methods are constructed
      for maximal efficiency in the case that some of the composition
      factors are LinearOps. If all operators from some factor on to
      the end of a composition are linear, then the value of the
      partial composition of the preceding factors need not be
      computed, only the value of its derivative, as the value plays
      no role in the evaluation of the remaining factors, which act
      only on the tangent part, being linear. In particular, workspace
      does not need to be allocated to hold this value. For
      large-scale computation, the efficiency obtained by
      distinguishing the linear and nonlinear cases can be
      considerable.

      Note on structure: OpComp is a handle class, which owns
      dynamically allocated instances of its Op data members (via
      clone). This design is efficient if Operator instances are kept
      lightweight.

  */

  template<class Scalar>
  class OpComp: public Operator<Scalar> {

  private:

    mutable std::vector<Operator<Scalar> *> opvec;
    mutable bool applied;


  protected:

    /** composition */
    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & val) const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: OpComp::apply\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	// set flag to indicate finish of initialization
	applied = true;

	// allocate intermediate vectors via evaluation
	// special case: one op only, no tmp vector allocation needed
	if (opvec.size()==1) 
	  this->export_apply(*(opvec[0]),x,val);
	else {
	  std::vector<OperatorEvaluation<Scalar> *> opeval(opvec.size()-1);
	  opeval[0] = new OperatorEvaluation<Scalar>(*(opvec[0]),x);
	  for (int i=1;i<(int)opvec.size()-1;i++) 
	    opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),opeval[i-1]->getValue());
	  this->export_apply(*(opvec[opvec.size()-1]),opeval[opvec.size()-2]->getValue(),val);
	  for (int i=opvec.size()-2;i>-1;i--) delete opeval[i];
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::apply\n";
	throw e;
      }
    }

    /** implements the chain rule to apply the derivative */
    void applyDeriv(const Vector<Scalar> & x, 
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & dy) const {
      try {
  
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: OpComp::applyDeriv\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	// set flag to indicate finish of initialization
	applied = true;

	// allocate intermediate vectors via evaluation
	// special case: one op only, no tmp vector allocation needed
	if (opvec.size()==1) 
	  this->export_applyDeriv(*(opvec[0]),x,dx,dy);

	// all other cases handled uniformly
	else {

	  std::vector<LinearOp<Scalar> *> linop(opvec.size(),NULL); // NB: pointer copy, no allocation
	  std::vector<OperatorEvaluation<Scalar> *> opeval(opvec.size(), NULL);
	  std::vector<LinearOpEvaluation<Scalar> *> lineval(opvec.size(),NULL);

	  // find last non-linear op 
	  int lastlin=opvec.size();

	  while ((lastlin>0) && (linop[lastlin-1]=dynamic_cast<LinearOp<Scalar> *>(opvec[lastlin-1])) ) {
	    lastlin--;
	  }
	  for (int i=0;i<lastlin;i++) {
	    if (i==0) {
	      opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),x);
	      lineval[i] = new LinearOpEvaluation<Scalar>(opeval[i]->getDeriv(),dx);
	    }
	    else if (i==(int)opvec.size()-1) {
	      opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),opeval[i-1]->getValue());
	      opeval[i]->getDeriv().applyOp(lineval[i-1]->getValue(),dy);	
	    }
	    else {
	      opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),opeval[i-1]->getValue());
	      lineval[i] = new LinearOpEvaluation<Scalar>(opeval[i]->getDeriv(),lineval[i-1]->getValue());
	    }
	  }
	  for (int i=lastlin;i<(int)opvec.size();i++) {
	    // last
	      if (i==(int)opvec.size()-1) 
	      this->export_apply(*(opvec[i]),lineval[i-1]->getValue(),dy);    
	    // middle
	    else if (i > 0) 
	      lineval[i]=new LinearOpEvaluation<Scalar>(*linop[i],lineval[i-1]->getValue());
	    // first
	    else
	      lineval[0] = new LinearOpEvaluation<Scalar>(*linop[0],dx);
	  }
	  
	  // clean up
	  for (int i=opvec.size()-1;i>-1;i--) { 
	    if (lineval[i]) delete lineval[i];
	    if (opeval[i]) delete opeval[i];
	  }
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::applyDeriv\n";
	throw e;
      }
    }

    /** the chain rule, backwards - in effect, the adjoint state
	method - however, all data is stored, no attempt at
	checkpointing! */
    void applyAdjDeriv(const Vector<Scalar> & x, 
		       const Vector<Scalar> & dy,
		       Vector<Scalar> & dx) const {
      try {
	// cerr<<"OpComp::applyAdjDeriv 0\n";
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: OpComp::applyAdjDeriv\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	// set flag to indicate finish of initialization
	applied = true;

	// allocate intermediate vectors via evaluation
	// special case: one op only, no tmp vector allocation needed
	if (opvec.size()==1) 
	  this->export_applyAdjDeriv(*(opvec[0]),x,dy,dx);

	// all other cases handled uniformly
	else {
	  std::vector<LinearOp<Scalar> *> linop(opvec.size(),NULL); // NB: pointer copy, no allocation
	  std::vector<OperatorEvaluation<Scalar> *> opeval(opvec.size(),NULL);
	  std::vector<LinearOpAdjEvaluation<Scalar> *> lineval(opvec.size(),NULL);

	  // find last non-linear op 
	  int lastlin=opvec.size();

	  while ((lastlin > 0) && (linop[lastlin-1]=dynamic_cast<LinearOp<Scalar> *>(opvec[lastlin-1]))) {
	    lastlin--;
	  }

	  for (int i=0;i<lastlin;i++) {
	    if (i==0) {
	      opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),x);
	    }
	    else {
	      opeval[i] = new OperatorEvaluation<Scalar>(*(opvec[i]),opeval[i-1]->getValue());
	    }
	  }

	  for (int i=opvec.size()-1;i>lastlin-1;i--) {
	    // note that opvec.size() > 1 here, so these branches are indep.
	    // last
	      if (i==(int)opvec.size()-1)  
	      lineval[i]=new LinearOpAdjEvaluation<Scalar>(*(linop[i]),dy);
	    // middle
	    else if (i>0)
	      lineval[i]=new LinearOpAdjEvaluation<Scalar>(*(linop[i]),lineval[i+1]->getValue());
	    // first
	    else 
	      linop[0]->applyAdjOp(lineval[1]->getValue(),dx);
	  }
	  for (int i=lastlin-1;i>-1;i--) {
	    // last step
	    if (i==0) {
	      opeval[i]->getDeriv().applyAdjOp(lineval[i+1]->getValue(),dx);	
	    }
	    // in case it's ALL nonlinear
	    else if (i==(int)opvec.size()-1) {
	      lineval[i] = new LinearOpAdjEvaluation<Scalar>(opeval[i]->getDeriv(),dy);
	    }
	    // generic nonlinear step
	    else {
	      lineval[i] = new LinearOpAdjEvaluation<Scalar>(opeval[i]->getDeriv(),lineval[i+1]->getValue());
	    }
	  }
	  
	  for (int i=opvec.size()-1;i>-1;i--) if (opeval[i]) delete opeval[i];
	  for (int i=0;i<(int)opvec.size();i++)  if (lineval[i]) delete lineval[i];
	 
	}
      }
      catch (RVLException & e) {	  
	e<<"\ncalled from OpComp::applyAdjDeriv\n";
	throw e;
      }
    }

    /** implements the chain rule to apply the second order derivative */
    void applyDeriv2(const Vector<Scalar> & x,
		     const Vector<Scalar> & dx0,
		     const Vector<Scalar> & dx1,
		     Vector<Scalar> & dy) const {
      try {
	
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: OpComp::applyDeriv2\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	// set flag to indicate finish of initialization
	applied = true;
        
	// allocate intermediate vectors via evaluation
	// special case: one op only, no tmp vector allocation needed
	if (opvec.size()==1)
	  this->export_applyDeriv2(*(opvec[0]),x,dx0,dx1,dy);
	else if(opvec.size()==2){
	  std::vector<OperatorEvaluation<Scalar> *> opeval(opvec.size(), NULL);
	  opeval[0] = new OperatorEvaluation<Scalar>(*(opvec[0]),x);
	  opeval[1] = new OperatorEvaluation<Scalar>(*(opvec[1]),opeval[0]->getValue());
	  Vector<Scalar> tmp(opvec[1]->getRange());
	  Vector<Scalar> dgx0(opvec[1]->getDomain());
	  Vector<Scalar> dgx1(opvec[1]->getDomain());
	  Vector<Scalar> d2gx(opvec[1]->getDomain());
          
	  opeval[0]->getDeriv().applyOp(dx0,dgx0);
	  opeval[0]->getDeriv().applyOp(dx1,dgx1);
	  opeval[0]->getDeriv2().applyOp(dx0,dx1,d2gx);
	  opeval[1]->getDeriv2().applyOp(dgx0,dgx1,tmp);
	  opeval[1]->getDeriv().applyOp(d2gx,dy);
	  dy.linComb(1.0, tmp);
	  for (int i=opvec.size()-1;i>-1;i--) if (opeval[i]) delete opeval[i];
          
	}
	// all other cases handled uniformly
	else {
	  RVLException e;
	  e<<"Error: OpComp::applyDeriv2\n";
	  e<<"deriv2 for more than two operators has not been implemented\n";
	  throw e;
          
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::applyDeriv2\n";
	throw e;
      }
    }
    
    void applyAdjDeriv2(const Vector<Scalar> & x,
			const Vector<Scalar> & dx0,
			const Vector<Scalar> & dy,
			Vector<Scalar> & dx1) const {
      try {
	if (opvec.size()<1) {
	  RVLException e;
	  e<<"Error: OpComp::applyAdjDeriv2\n";
	  e<<"object not initialized\n";
	  throw e;
	}
	// set flag to indicate finish of initialization
	applied = true;
	if (opvec.size()==1)
	  this->export_applyAdjDeriv2(*(opvec[0]),x,dx0,dy,dx1);
	else if(opvec.size()==2){
	  std::vector<OperatorEvaluation<Scalar> *> opeval(opvec.size(), NULL);
	  opeval[0] = new OperatorEvaluation<Scalar>(*(opvec[0]),x);
	  opeval[1] = new OperatorEvaluation<Scalar>(*(opvec[1]),opeval[0]->getValue());
	  Vector<Scalar> tmp(opvec[0]->getDomain());
	  Vector<Scalar> tmp0(opvec[1]->getDomain());
	  Vector<Scalar> dftdy(opvec[1]->getDomain());
	  Vector<Scalar> dgx0(opvec[1]->getDomain());
          
	  opeval[0]->getDeriv().applyOp(dx0,dgx0);
	  opeval[1]->getDeriv2().applyAdjOp(dgx0,dy,tmp0);
	  opeval[0]->getDeriv().applyAdjOp(tmp0,tmp);
	  
	  opeval[1]->getDeriv().applyAdjOp(dy,dftdy);
	  opeval[0]->getDeriv2().applyAdjOp(dx0,dftdy,dx1);
	  dx1.linComb(1.0, tmp);
	  for (int i=opvec.size()-1;i>-1;i--) if (opeval[i]) delete opeval[i];
          
	}
	// all other cases handled uniformly
	else {
	  RVLException e;
	  e<<"Error: OpComp::applyAdjDeriv2\n";
	  e<<"deriv2 for more than two operators has not been implemented\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::applyAdjDeriv2\n";
	throw e;
      }
    }
    
    /** virtual copy constructor: make a complete new copy including
	internal workspace. Usually implemented with operator new and
	copy constructor of concrete child class.
    */

    Operator<Scalar> * clone() const { return new OpComp<Scalar>(*this); }
    
  public:

    OpComp(): opvec(0), applied(false) {}

    OpComp(OpComp<Scalar> const & oc)
      : opvec(oc.opvec.size()), applied(false) {
	for (int i=0;i<(int)opvec.size(); i++) {
	  opvec[i]=RVL::Operator<Scalar>::export_clone(*(oc.opvec[i]));
      }
    }

    /** Run-time initialization - standard use case
    */
    void setNext(Operator<Scalar> const & opref) {
      try {
	if (applied) {
	  RVLException e;
	  e<<"Error: OpComp::setNext (Operator)\n";
	  e<<"operator composition already initialized, may not alter\n";
	  throw e;
	}
	if (opvec.size() > 0) {
	  // last one was an Operator, and there is at least one of those
	  if (opvec[opvec.size()-1]->getRange() != opref.getDomain())  {
	    RVLException e;
	    e<<"Error: OpComp::setNext \n";
	    e<<"domain of next operator differs from range of previous\n";
	    e<<"============== BEGIN RANGE OF PREVIOUS ===============\n";
	    (opvec[opvec.size()-1]->getRange()).write(e);
	    e<<"==============   END RANGE OF PREVIOUS ===============\n";
	    e<<"============== BEGIN DOMAIN OF NEXT    ===============\n";
	    opref.getDomain().write(e);
	    e<<"==============   END DOMAIN OF NEXT    ===============\n";	    	    throw e;
	  }
	}
	opvec.push_back(RVL::Operator<Scalar>::export_clone(opref));
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::setNext(Operator)\n";
	throw e;
      }
    }

    // old-style initializations - deprecated 
    /** composition of two operators */
    OpComp(Operator<Scalar> const & op1ref,
	   Operator<Scalar> const & op2ref)
      : opvec(0), applied(false) {
      try {
	this->setNext(op1ref);
	this->setNext(op2ref);
      }
      catch (RVLException & e) {
	e<<"Error: OpComp pair constructor from setNext\n";
	throw e;
      }
    }

    /** composition of three operators */
    OpComp(Operator<Scalar> const & op1ref,
	   Operator<Scalar> const & op2ref,
	   Operator<Scalar> const & op3ref)
      : opvec(0), applied(false) {
      try {
	this->setNext(op1ref);
	this->setNext(op2ref);
	this->setNext(op3ref);
      }
      catch (RVLException & e) {
	e<<"Error: OpComp triple constructor from setNext\n";
	throw e;
      }
    }

    /** composition of four operators */
    OpComp(Operator<Scalar> const & op1ref,
	   Operator<Scalar> const & op2ref,
	   Operator<Scalar> const & op3ref,
	   Operator<Scalar> const & op4ref)
      : opvec(0), applied(false) {
      try {
	this->setNext(op1ref);
	this->setNext(op2ref);
	this->setNext(op3ref);
	this->setNext(op4ref);
      }
      catch (RVLException & e) {
	e<<"Error: OpComp quadruple constructor from setNext\n";
	throw e;
      }
    }

    /** composition of five operators */
    OpComp(Operator<Scalar> const & op1ref,
	   Operator<Scalar> const & op2ref,
	   Operator<Scalar> const & op3ref,
	   Operator<Scalar> const & op4ref,
	   Operator<Scalar> const & op5ref)
      : opvec(0), applied(false) {
      try {
	this->setNext(op1ref);
	this->setNext(op2ref);
	this->setNext(op3ref);
	this->setNext(op4ref);
	this->setNext(op5ref);
      }
      catch (RVLException & e) {
	e<<"Error: OpComp quintuple constructor from setNext\n";
	throw e;
      }
    }

    ~OpComp() {
	for (int i=0;i<(int)opvec.size();i++) { delete opvec[i]; }
    }

    /** access to domain and range */
    const Space<Scalar> & getDomain() const {
      try {
	if (opvec.size() > 0) {
	  applied = true;
	  return opvec[0]->getDomain();
	}
	RVLException e;
	e<<"Error: OpComp::getDomain\n";
	e<<"not initialized - no factors specified\n";
	throw e;
      }
    
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::getDomain\n";
	throw e;
      }
    }

    const Space<Scalar> & getRange() const {
      try {
	if (opvec.size() > 0) {
	  applied = true;
	  return opvec[opvec.size()-1]->getRange();
	}
	RVLException e;
	e<<"Error: OpComp::getRange\n";
	e<<"not initialized - no factors specified\n";
	throw e;
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::getRange\n";
	throw e;
      }
    }

    ostream & write(ostream & str) const {
      try {
	if (opvec.size() > 0) {
	  applied = true;
	  str<<"OpComp: Operator composition\n";
	  str<<"-- number of factors = "<<opvec.size()<<"\n";
	  for (int i=0;i<(int)opvec.size(); i++) {
	    str<<"\nfactor "<<i<<":\n";
	    opvec[i]->write(str);
	  }
	  return str;
	}
	else {
	  RVLException e;
	  e<<"Error: OpComp::write\n";
	  e<<"not initialized - no factors specified\n";
	  throw e;
	}
      }
      catch (RVLException & e) {
	e<<"\ncalled from OpComp::write\n";
	throw e;
      }
    }
    
  };

  template<class Scalar>
  DerivEvaluation<Scalar> * 
  OperatorWithInvertibleDeriv<Scalar>::createDerivEvaluation
  (OperatorEvaluation<Scalar> & opeval) const {
    return new InvertibleDerivEvaluation<Scalar>(opeval);
  }
  
  /*
  template<class Scalar>
  bool OperatorWithInvertibleDeriv<Scalar>::checkInverseDeriv
  (const Vector<Scalar> & x,
   const Vector<Scalar> & dy,
   NormRetType tol,
   ostream & str) {
    Vector<Scalar> invdy(this->getDomain());
    Vector<Scalar> yd(this->getRange());
    applyInverseDeriv(x, dy, invdy);
    applyDeriv(x, invdy, yd);
    yd.linComb(-1.0, dy);
    NormRetType n;
    n = yd.norm();
    if( n < tol ) {
      str << "Success.  |DF(x)*inv(DF(x))*dy - dy| = " 
	  << n << " < tol = " << tol << endl;
      return true;
    } else {
      str << "Failure.  |DF(x)*inv(DF(x))*dy - dy| = " 
	  << n << " >= tol = " << tol << endl;
      return false;
    }
  }
  */


  /** IdentityOp is a concrete class implementing identity operator.
   */

  template<class Scalar>
  class IdentityOp: public Operator<Scalar> {

  private:

    Space<Scalar> const & dom;
    Space<Scalar> const & rng;

    IdentityOp();
  
  protected:

    void apply(const Vector<Scalar> & x, 
	       Vector<Scalar> & val) const {
      try {
	SpaceTest(this->getDomain(),x,"RVL::IdentityOp::apply (dom test)");
	SpaceTest(this->getRange(),val,"RVL::IdentityOp::apply (rng test)");
	//SpaceTest(x.getSpace(),val,"RVL::IdentityOp::apply (space test)");
	val.copy(x);
      }
      catch (RVLException & e) {
	e<<"\ncalled from IdentityOp::apply\n";
	throw e;
      }
    }

    void applyDeriv(const Vector<Scalar> & x, 
		    const Vector<Scalar> & dx,
		    Vector<Scalar> & dy) const {
      try {
	SpaceTest(this->getDomain(),x,"RVL::IdentityOp::applyDeriv (dom test x)");
	SpaceTest(this->getDomain(),dx,"RVL::IdentityOp::applyDeriv (dom test dx)");
	SpaceTest(this->getRange(),dy,"RVL::IdentityOp::applyDeriv (rng test)");
	dy.copy(dx);
      }
      catch (RVLException & e) {
	e<<"\ncalled from IdentityOp::applyDeriv\n";
	throw e;
      }
    }

    void applyAdjDeriv(const Vector<Scalar> & x, 
		       const Vector<Scalar> & dy,
		       Vector<Scalar> & dx) const {
      try {
	SpaceTest(this->getDomain(),x,"RVL::IdentityOp::applyAdjDeriv (dom test x)");
	SpaceTest(this->getDomain(),dx,"RVL::IdentityOp::applyAdjDeriv (dom test dx)");
	SpaceTest(this->getRange(),dy,"RVL::IdentityOp::applyAdjDeriv (rng test)");
	dx.copy(dy);
      }
      catch (RVLException & e) {
	e<<"\ncalled from IdentityOp::applyAdjDeriv\n";
	throw e;
      }
    }

    Operator<Scalar> * clone() const { return new IdentityOp<Scalar>(*this); }
    
  public:

    IdentityOp(const Space<Scalar> & sp)
      :dom(sp), rng(sp) {}

    IdentityOp(const IdentityOp<Scalar> & c) 
      : dom(c.getDomain()), rng(c.getRange()){}

    ~IdentityOp() {}

    /** access to domain and range */
    const Space<Scalar> & getDomain() const {
      return dom;
    }

    const Space<Scalar> & getRange() const {
      return rng;
    }

    ostream & write(ostream & str) const {
      str<<"IdentityOp: Identity Operator\n";
      return str;
    }
    
  };




  
}
#endif

