/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.14 (r7114) - 22 Oct 2018 09:36
*/
#include <adBuffer.h>
#include "cstd.h"

/*
  Differentiation of sggrad in reverse (adjoint) mode:
   gradient     of useful results: *y
   with respect to varying inputs: *x *y
   RW status of diff variables: *x:out *y:in-out
   Plus diff mem management of: x:in y:in

 staggered grid derivative in dimension idx
 */
void sggrad_b(int *gsx, int *gex, int *gsy, int *gey, int *csy, int *cey, int 
        m, int idx, int dim, float *x, float *xb, float *a, float *y, float *
        yb) {
    // only one error return, if idx out-of-range
    int ierr = 0;
    // compute offsets, lengths
    int *oxy;
    int sggrad;
    oxy = (int *)malloc(dim*sizeof(int));
    int *nx;
    nx = (int *)malloc(dim*sizeof(int));
    int *ny;
    ny = (int *)malloc(dim*sizeof(int));
    for (int i = 0; i < dim; ++i) {
        oxy[i] = gsy[i] - gsx[i];
        nx[i] = gex[i] - gsx[i] + 1;
        ny[i] = gey[i] - gsy[i] + 1;
    }
    if (idx == 0) {
        pushPointer8(ny);
        pushPointer8(nx);
        pushPointer8(oxy);
        popPointer8((void **)&oxy);
        popPointer8((void **)&nx);
        popPointer8((void **)&ny);
        *xb = 0.0;
        for (int i1 = cey[1]-gsy[1]; i1 > csy[1]-gsy[1]-1; --i1) {
            for (int j = m-1; j > 0; --j)
                for (int i0 = cey[0]-gsy[0]; i0 > csy[0]-gsy[0]-1; --i0) {
                    xb[i0 + oxy[0] + 1 + j + (i1+oxy[1])*nx[0]] = xb[i0 + oxy[
                        0] + 1 + j + (i1+oxy[1])*nx[0]] + a[j]*yb[i0+i1*ny[0]]
                    ;
                    xb[i0 + oxy[0] - j + (i1+oxy[1])*nx[0]] = xb[i0 + oxy[0] -
                        j + (i1+oxy[1])*nx[0]] - a[j]*yb[i0+i1*ny[0]];
                }
            for (int i0 = cey[0]-gsy[0]; i0 > csy[0]-gsy[0]-1; --i0) {
                xb[i0 + oxy[0] + 1 + (i1+oxy[1])*nx[0]] = xb[i0 + oxy[0] + 1 +
                    (i1+oxy[1])*nx[0]] + a[0]*yb[i0+i1*ny[0]];
                xb[i0 + oxy[0] + (i1+oxy[1])*nx[0]] = xb[i0 + oxy[0] + (i1+oxy
                    [1])*nx[0]] - a[0]*yb[i0+i1*ny[0]];
                yb[i0 + i1*ny[0]] = 0.0;
            }
        }
    } else if (idx == 1) {
        pushPointer8(ny);
        pushPointer8(nx);
        pushPointer8(oxy);
        popPointer8((void **)&oxy);
        popPointer8((void **)&nx);
        popPointer8((void **)&ny);
        *xb = 0.0;
        for (int i1 = cey[1]-gsy[1]; i1 > csy[1]-gsy[1]-1; --i1) {
            for (int j = m-1; j > 0; --j)
                for (int i0 = cey[0]-gsy[0]; i0 > csy[0]-gsy[0]-1; --i0) {
                    xb[i0 + oxy[0] + (i1+oxy[1]+1+j)*nx[0]] = xb[i0 + oxy[0] +
                        (i1+oxy[1]+1+j)*nx[0]] + a[j]*yb[i0+i1*ny[0]];
                    xb[i0 + oxy[0] + (i1+oxy[1]-j)*nx[0]] = xb[i0 + oxy[0] + (
                        i1+oxy[1]-j)*nx[0]] - a[j]*yb[i0+i1*ny[0]];
                }
            for (int i0 = cey[0]-gsy[0]; i0 > csy[0]-gsy[0]-1; --i0) {
                xb[i0 + oxy[0] + (i1+oxy[1]+1)*nx[0]] = xb[i0 + oxy[0] + (i1+
                    oxy[1]+1)*nx[0]] + a[0]*yb[i0+i1*ny[0]];
                xb[i0 + oxy[0] + (i1+oxy[1])*nx[0]] = xb[i0 + oxy[0] + (i1+oxy
                    [1])*nx[0]] - a[0]*yb[i0+i1*ny[0]];
                yb[i0 + i1*ny[0]] = 0.0;
            }
        }
    } else
        *xb = 0.0;
    free(ny);
    free(nx);
    free(oxy);
}
