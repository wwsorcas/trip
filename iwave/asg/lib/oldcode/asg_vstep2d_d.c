/*        Generated by TAPENADE     (INRIA, Ecuador team)
	  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
*/
/* hand clean up 2016 Oct 21 WWS */
/*
  Differentiation of asg_vstep2d in forward (tangent) mode:
  variations   of useful results: **v0 **v1
  with respect to varying inputs: **v0 **v1 **buoy **p0 **p1
  RW status of diff variables: **v0:in-out **v1:in-out **buoy:in
  **p0:in **p1:in
  Plus diff mem management of: v0:in *v0:in v1:in *v1:in buoy:in
  *buoy:in p0:in *p0:in p1:in *p1:in gradp:in *gradp:in


  void asg_vstep2d(float ** restrict buoy,
  float ** restrict p0,float ** restrict p1,
  float ** restrict v0,float ** restrict v1,
  float ** restrict ev, float ** restrict evp,
  float ** restrict gradp,
  int * gsc_v0, int * gec_v0,
  int * gsc_v1, int * gec_v1,
  int * lbc, int * rbc,
  int maxoff,float ** restrict c,
  FILE * stream) {
*/
#include "cstd.h"
//#define LOCAL_VERBOSE
// signature for tapenade
void asg_vstep2d_d(float ** restrict buoy,
		   float ** restrict buoyd,
		   float ** restrict p0,
		   float ** restrict p0d,
		   float ** restrict p1,
		   float ** restrict p1d,
		   float ** restrict v0,
		   float ** restrict v0d,
		   float ** restrict v1,
		   float ** restrict v1d, 
		   float ** restrict ev,
		   float ** restrict evp,
		   float ** restrict gradp,
		   float ** restrict gradpd,
		   int *gsc_v0, 
		   int *gec_v0,
		   int *gsc_v1,
		   int *gec_v1,
		   int *lbc,
		   int *rbc,
		   int maxoff,
		   float ** restrict c) {
  int i0, i1;
  int ioff;
  //    **gradpd = 0.0;
  for (i1 = gsc_v0[1]; i1 < gec_v0[1]+1; ++i1) {
    for (i0 = gsc_v0[0]; i0 < gec_v0[0]+1; ++i0) {
      gradpd[0][i0] = 0.0;
      gradp[0][i0] = 0;
    }
    for (ioff = 0; ioff < maxoff; ++ioff)
      for (i0 = gsc_v0[0]; i0 < gec_v0[0]+1; ++i0) {
	gradpd[0][i0] = gradpd[0][i0] + c[0][ioff]*(p0d[i1][i0+ioff+1]
						    -p0d[i1][i0-ioff]);
	gradp[0][i0] += c[0][ioff]*(p0[i1][i0+ioff+1]-p0[i1][i0-ioff]);
      }
    for (i0 = gsc_v0[0]; i0 < gec_v0[0]+1; ++i0) {
      v0d[i1][i0] = evp[0][i0]*(ev[0][i0]*v0d[i1][i0]-0.5*
				((buoyd[i1][i0]+buoyd[i1][i0+1])*
				 gradp[0][i0]+(buoy[i1][i0]+buoy[i1][i0+1])*
				 gradpd[0][i0]));
      v0[i1][i0] = evp[0][i0]*(v0[i1][i0]*ev[0][i0]-0.5*
			       (buoy[i1][i0]+buoy[i1][i0+1])*gradp[0][i0]);
    }
  }
  for (i1 = gsc_v1[1]; i1 < gec_v1[1]+1; ++i1) {
    for (i0 = gsc_v1[0]; i0 < gec_v1[0]+1; ++i0) {
      gradpd[1][i0] = 0.0;
      gradp[1][i0] = 0;
    }
    for (ioff = 0; ioff < maxoff; ++ioff)
      for (i0 = gsc_v1[0]; i0 < gec_v1[0]+1; ++i0) {
	gradpd[1][i0] = gradpd[1][i0] + c[1][ioff]*(p1d[i1+ioff+1][i0]
						    -p1d[i1-ioff][i0]);
	gradp[1][i0] += c[1][ioff]*(p1[i1+ioff+1][i0]-p1[i1-ioff][i0]);
      }
    for (i0 = gsc_v1[0]; i0 < gec_v1[0]+1; ++i0) {
      v1d[i1][i0] = evp[1][i1]*(ev[1][i1]*v1d[i1][i0]-0.5*
				((buoyd[i1][i0]+buoyd[i1+1][i0])*
				 gradp[1][i0]+(buoy[i1][i0]+buoy[i1+1][i0])*
				 gradpd[1][i0]));
      v1[i1][i0] = evp[1][i1]*(v1[i1][i0]*ev[1][i1]-0.5*
			       (buoy[i1][i0]+buoy[i1+1][i0])*gradp[1][i0]);
    }
  }
  if (lbc[0])
    for (i1 = gsc_v0[1]; i1 < gec_v0[1]+1; ++i1)
      for (ioff = 1; ioff < maxoff; ++ioff) {
	v0d[i1][gsc_v0[0] - ioff] = v0d[i1][gsc_v0[0] + ioff - 1];
	v0[i1][gsc_v0[0] - ioff] = v0[i1][gsc_v0[0] + ioff - 1];
      }
  if (rbc[0])
    for (i1 = gsc_v0[1]; i1 < gec_v0[1]+1; ++i1)
      for (ioff = 1; ioff < maxoff; ++ioff) {
	v0d[i1][gec_v0[0] + ioff] = v0d[i1][gec_v0[0] - ioff + 1];
	v0[i1][gec_v0[0] + ioff] = v0[i1][gec_v0[0] - ioff + 1];
      }
  if (lbc[1])
    for (i0 = gsc_v1[0]; i0 < gec_v1[0]+1; ++i0)
      for (ioff = 1; ioff < maxoff; ++ioff) {
	v1d[gsc_v1[1] - ioff][i0] = v1d[gsc_v1[1] + ioff - 1][i0];
	v1[gsc_v1[1] - ioff][i0] = v1[gsc_v1[1] + ioff - 1][i0];
      }
  if (rbc[1])
    for (i0 = gsc_v1[0]; i0 < gec_v1[0]+1; ++i0)
      for (ioff = 1; ioff < maxoff; ++ioff) {
	v1d[gec_v1[1] + ioff][i0] = v1d[gec_v1[1] - ioff + 1][i0];
	v1[gec_v1[1] + ioff][i0] = v1[gec_v1[1] - ioff + 1][i0];
      }
}
